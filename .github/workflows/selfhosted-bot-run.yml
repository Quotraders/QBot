name: "üöÄ Bot Execution Test"

on:
  workflow_dispatch:
    inputs:
      timeout_minutes:
        description: 'Bot execution timeout (minutes)'
        required: false
        default: '5'
        type: string
      dry_run:
        description: 'Enable DRY_RUN mode (paper trading)'
        required: false
        default: true
        type: boolean

permissions:
  contents: read

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"
  DOTNET_VERSION: '8.0.x'

jobs:
  run-bot:
    name: "Run Trading Bot"
    runs-on: [self-hosted, windows, x64]
    timeout-minutes: 15  # Covers max runtime + startup/shutdown buffer
    
    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: "üîß Setup .NET SDK"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "üîß Setup .NET Environment"
        shell: pwsh
        env:
          TOPSTEPX_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          TOPSTEPX_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
          TOPSTEPX_ACCOUNT_ID: ${{ secrets.TOPSTEPX_ACCOUNT_ID }}
          TOPSTEPX_ACCOUNT_NAME: ${{ secrets.TOPSTEPX_ACCOUNT_NAME }}
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET Environment Setup"
          Write-Output "=================================================="
          Write-Output ""
          
          # Check .NET installation
          $DotnetVersion = dotnet --version
          Write-Output "‚úÖ .NET SDK Version: $DotnetVersion"
          Write-Output ""
          Write-Output "üìã .NET SDK Information:"
          dotnet --info
          Write-Output ""
          
          # Create .env file from secrets
          @"
          # Trading Mode Configuration
          DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          ENABLE_DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          LIVE_ORDERS=0
          
          # TopstepX API Configuration
          ENABLE_TOPSTEPX=1
          TOPSTEPX_API_BASE=${TOPSTEPX_API_BASE}
          TOPSTEPX_API_KEY=${TOPSTEPX_API_KEY}
          TOPSTEPX_USERNAME=${TOPSTEPX_USERNAME}
          TOPSTEPX_ACCOUNT_ID=${TOPSTEPX_ACCOUNT_ID}
          TOPSTEPX_ACCOUNT_NAME=${TOPSTEPX_ACCOUNT_NAME}
          "@ | Out-File -FilePath .env -Encoding UTF8
          
          Write-Output "‚úÖ Environment configuration created"
          Write-Output ""
          
          # Validate credentials
          if ([string]::IsNullOrEmpty($env:TOPSTEPX_API_KEY) -or [string]::IsNullOrEmpty($env:TOPSTEPX_USERNAME) -or [string]::IsNullOrEmpty($env:TOPSTEPX_ACCOUNT_ID)) {
            Write-Output "‚ùå ERROR: Required TopstepX credentials are missing!"
            exit 1
          }
          
          Write-Output "üì¶ Restoring NuGet packages..."
          dotnet restore TopstepX.Bot.sln
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          Write-Output "‚úÖ NuGet restore completed"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Solution"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è Building Trading Bot Solution"
          Write-Output "=================================================="
          Write-Output ""
          
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Output"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç Verifying Build Output"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            $FileSize = (Get-Item $DllPath).Length
            $FileSizeMB = [math]::Round($FileSize / 1MB, 2)
            Write-Output "‚úÖ Build artifacts verified"
            Write-Output "   UnifiedOrchestrator.dll: $FileSizeMB MB"
          } else {
            Write-Output "‚ùå Build artifacts NOT FOUND at: $DllPath"
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Run Trading Bot"
        id: bot_run
        continue-on-error: true
        shell: pwsh
        env:
          TOPSTEPX_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          TOPSTEPX_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
          TOPSTEPX_ACCOUNT_ID: ${{ secrets.TOPSTEPX_ACCOUNT_ID }}
          TOPSTEPX_ACCOUNT_NAME: ${{ secrets.TOPSTEPX_ACCOUNT_NAME }}
          PROJECT_X_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          PROJECT_X_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ Starting Trading Bot"
          Write-Output "=================================================="
          Write-Output ""
          
          # Load environment variables
          if (Test-Path ".env") {
            Get-Content .env | ForEach-Object {
              if ($_ -match '^([^#][^=]+)=(.*)$') {
                [Environment]::SetEnvironmentVariable($matches[1], $matches[2])
              }
            }
          }
          
          # Override with DRY_RUN from input
          $env:DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          $env:ENABLE_DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          Write-Output "‚ö†Ô∏è DRY_RUN mode: ${{ github.event.inputs.dry_run }}"
          Write-Output ""
          
          # Set required Python/SDK environment variables
          $env:PYTHON_EXECUTABLE = "python"
          $env:ADAPTER_MAX_RETRIES = "3"
          $env:ADAPTER_BASE_DELAY = "1.0"
          $env:ADAPTER_MAX_DELAY = "8.0"
          $env:ADAPTER_TIMEOUT = "30.0"
          
          # Verify Python and project-x-py SDK are available
          Write-Output "üêç Checking Python environment..."
          try {
            $pythonVersion = python --version 2>&1
            Write-Output "‚úÖ Python: $pythonVersion"
          } catch {
            Write-Output "‚ö†Ô∏è WARNING: Python not found - bot may run in degraded mode"
          }
          
          # Check if project-x-py is installed
          $sdkCheck = python -c "import project_x_py; print('SDK OK')" 2>&1
          if ($LASTEXITCODE -eq 0) {
            Write-Output "‚úÖ project-x-py SDK is installed"
          } else {
            Write-Output "‚ö†Ô∏è WARNING: project-x-py SDK not found - bot will run without live data"
            Write-Output "   To install: pip install 'project-x-py[all]'"
          }
          Write-Output ""
          
          # Create log capture directory
          $LogDir = "$env:TEMP/qbot-bot-run-logs"
          if (-not (Test-Path $LogDir)) {
            New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
          }
          
          $Timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          $LogFile = "$LogDir/bot-run-$Timestamp.log"
          $ErrorLogFile = "$LogDir/bot-error-$Timestamp.log"
          
          Write-Output "üìù Bot output will be captured to: $LogFile"
          Write-Output "üìù Bot errors will be captured to: $ErrorLogFile"
          Write-Output ""
          Write-Output "Starting bot execution..."
          Write-Output "=================================================="
          Write-Output ""
          
          # Run the bot and capture all output
          $ProcessInfo = Start-Process -FilePath "dotnet" `
            -ArgumentList "run", "--project", "src/UnifiedOrchestrator/UnifiedOrchestrator.csproj", "--no-build", "-c", "Release" `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $LogFile `
            -RedirectStandardError $ErrorLogFile
          
          $BotPID = $ProcessInfo.Id
          Write-Output "‚úÖ Process started (PID: $BotPID)"
          Write-Output ""
          
          # Wait for process to exit or timeout
          $TimeoutSeconds = 420  # 7 minutes as requested
          $CheckInterval = 10
          $Elapsed = 0
          
          Write-Output "‚è±Ô∏è Waiting for bot to complete (timeout: $TimeoutSeconds seconds = 7 minutes)..."
          
          $ExitCode = $null
          while ($Elapsed -lt $TimeoutSeconds) {
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if (-not $BotProcess) {
              $ExitCode = $ProcessInfo.ExitCode
              break
            }
            
            Start-Sleep -Seconds $CheckInterval
            $Elapsed += $CheckInterval
            
            # Show progress every 60 seconds
            if (($Elapsed % 60) -eq 0) {
              Write-Output "‚è±Ô∏è Still running... ($Elapsed / $TimeoutSeconds seconds - $([Math]::Round($Elapsed/60, 1)) minutes)"
              
              # Output last 20 lines every 60 seconds for monitoring
              if (Test-Path $LogFile) {
                Write-Output "--- Recent bot output (last 20 lines) ---"
                Get-Content $LogFile -Tail 20 | ForEach-Object { Write-Output $_ }
                Write-Output "--- End recent output ---"
              }
            }
          }
          
          # Stop if timeout reached
          $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
          if ($BotProcess) {
            Write-Output ""
            Write-Output "‚è±Ô∏è Bot execution timeout after $TimeoutSeconds seconds (7 minutes)"
            Write-Output "üõë Stopping bot process gracefully..."
            
            # Try graceful shutdown first (SIGTERM equivalent)
            Stop-Process -Id $BotPID -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 5
            
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if ($BotProcess) {
              Write-Output "üî® Force stopping process..."
              Stop-Process -Id $BotPID -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 2
            }
            
            # Check for Python child processes and clean them up
            Write-Output "üßπ Cleaning up any orphaned Python processes..."
            Get-Process python* -ErrorAction SilentlyContinue | Where-Object {
              $_.StartTime -gt (Get-Date).AddMinutes(-10)
            } | Stop-Process -Force -ErrorAction SilentlyContinue
            
            $ExitCode = -1
          }
          
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "Bot Execution Summary:"
          Write-Output "  Exit Code: $(if ($ExitCode) { $ExitCode } else { 0 })"
          Write-Output "  Duration: $([Math]::Round($Elapsed/60, 1)) minutes"
          Write-Output "  Log File: $LogFile"
          Write-Output "  Error Log: $ErrorLogFile"
          Write-Output "=================================================="
          
          # Output last 150 lines of log for analysis
          Write-Output ""
          Write-Output "üìã Last 150 lines of bot output:"
          Write-Output "=================================================="
          if (Test-Path $LogFile) {
            Get-Content $LogFile -Tail 150
          }
          Write-Output "=================================================="
          
          # Output error log if it exists and has content
          Write-Output ""
          Write-Output "‚ùå Error log (if any):"
          Write-Output "=================================================="
          if (Test-Path $ErrorLogFile) {
            $errorContent = Get-Content $ErrorLogFile -Raw
            if ($errorContent -and $errorContent.Trim().Length -gt 0) {
              Write-Output $errorContent
            } else {
              Write-Output "(No errors logged)"
            }
          }
          Write-Output "=================================================="
          
          # Set outputs
          $ExitCodeValue = if ($ExitCode) { $ExitCode } else { 0 }
          "exit_code=$ExitCodeValue" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
          "log_file=$LogFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
          
          # Always consider timeout as success for diagnostic workflow
          if ($ExitCodeValue -eq -1) {
            Write-Output "‚è±Ô∏è Bot stopped after timeout (EXPECTED for 7-minute diagnostic run)"
          } elseif ($ExitCodeValue -eq 0) {
            Write-Output "‚úÖ Bot executed successfully"
          } else {
            Write-Output "‚ùå Bot execution failed with exit code: $ExitCodeValue"
          }
          
          # Don't fail the workflow for diagnostic purposes - we want to see logs
          Write-Output "üìä Workflow will continue to summary step for analysis"

      - name: "üìä Execution Summary"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üìä Bot Execution Test Summary"
          Write-Output "=================================================="
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_run.outputs.exit_code }}"
          $LogFile = "${{ steps.bot_run.outputs.log_file }}"
          
          if ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output "  Bot executed without errors"
          } elseif ($ExitCode -eq "-1") {
            Write-Output "‚è±Ô∏è Status: TIMEOUT"
            Write-Output "  Bot execution timed out (expected for continuous operation)"
          } else {
            Write-Output "‚ùå Status: FAILED"
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Check logs for errors"
          }
          
          Write-Output ""
          Write-Output "üìù Log Location: $LogFile"
          Write-Output ""
          Write-Output "=================================================="
