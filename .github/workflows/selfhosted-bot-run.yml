name: "üöÄ Self-Hosted Bot Execution Test"

on:
  workflow_dispatch:
    inputs:
      timeout_minutes:
        description: 'Bot execution timeout (minutes)'
        required: false
        default: '5'
        type: string

permissions:
  contents: read

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"

jobs:
  run-bot:
    name: "Run Trading Bot on Self-Hosted Runner"
    runs-on: self-hosted
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_minutes || '5') }}
    
    steps:
      - name: Configure Git
        run: |
          git config --global core.longpaths true
          git config --global core.symlinks false
      
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: "üîß Setup .NET SDK"
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}/.dotnet
        with:
          dotnet-version: '8.0.x'

      - name: "üîß Setup .NET Environment"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET Environment Setup"
          Write-Output "=================================================="
          Write-Output ""
          
          # Check .NET installation
          try {
            $DotnetVersion = dotnet --version
            Write-Output "‚úÖ .NET SDK Version: $DotnetVersion"
            Write-Output ""
            Write-Output "üìã .NET SDK Information:"
            dotnet --info
          } catch {
            Write-Output "‚ùå .NET SDK not found"
            Write-Output "Error: $($_.Exception.Message)"
            exit 1
          }
          
          Write-Output ""
          Write-Output "üì¶ Restoring NuGet packages..."
          dotnet restore TopstepX.Bot.sln
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          Write-Output "‚úÖ NuGet restore completed"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Solution"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è Building Trading Bot Solution"
          Write-Output "=================================================="
          Write-Output ""
          
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Output"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç Verifying Build Output"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            Write-Output "‚úÖ Build artifacts verified"
            Write-Output "   UnifiedOrchestrator.dll: $((Get-Item $DllPath).Length / 1MB | ForEach-Object { '{0:N2}' -f $_ }) MB"
          } else {
            Write-Output "‚ùå Build artifacts NOT FOUND at: $DllPath"
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Run Trading Bot (with Error Capture)"
        id: bot_run
        shell: pwsh
        continue-on-error: true
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ Starting Trading Bot"
          Write-Output "=================================================="
          Write-Output ""
          
          # Set DRY_RUN mode for safety
          $env:DRY_RUN = "true"
          Write-Output "‚ö†Ô∏è DRY_RUN mode enabled (safety mode)"
          Write-Output ""
          
          # Create log capture directory
          $LogDir = "$env:TEMP\qbot-bot-run-logs"
          New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
          
          $Timestamp = (Get-Date).ToString("yyyy-MM-dd_HH-mm-ss")
          $LogFile = "$LogDir\bot-run-$Timestamp.log"
          
          Write-Output "üìù Bot output will be captured to: $LogFile"
          Write-Output ""
          Write-Output "Starting bot execution..."
          Write-Output "=================================================="
          Write-Output ""
          
          # Run the bot and capture all output
          try {
            # Use Start-Process to capture output
            $ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo
            $ProcessInfo.FileName = "dotnet"
            $ProcessInfo.Arguments = "run --project src/UnifiedOrchestrator/UnifiedOrchestrator.csproj"
            $ProcessInfo.RedirectStandardOutput = $true
            $ProcessInfo.RedirectStandardError = $true
            $ProcessInfo.UseShellExecute = $false
            $ProcessInfo.CreateNoWindow = $true
            $ProcessInfo.WorkingDirectory = (Get-Location)
            
            # Copy environment variables to the new process
            foreach ($envVar in [Environment]::GetEnvironmentVariables().GetEnumerator()) {
              $ProcessInfo.Environment[$envVar.Name] = $envVar.Value
            }
            
            $Process = New-Object System.Diagnostics.Process
            $Process.StartInfo = $ProcessInfo
            
            # Event handlers for output
            $OutputBuilder = New-Object System.Text.StringBuilder
            $ErrorBuilder = New-Object System.Text.StringBuilder
            
            $OutputHandler = {
              if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
                $OutputBuilder.AppendLine($EventArgs.Data)
                Write-Output $EventArgs.Data
              }
            }
            
            $ErrorHandler = {
              if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
                $ErrorBuilder.AppendLine($EventArgs.Data)
                Write-Output "STDERR: $($EventArgs.Data)"
              }
            }
            
            Register-ObjectEvent -InputObject $Process -EventName OutputDataReceived -Action $OutputHandler | Out-Null
            Register-ObjectEvent -InputObject $Process -EventName ErrorDataReceived -Action $ErrorHandler | Out-Null
            
            Write-Output "üîÑ Starting process..."
            $Started = $Process.Start()
            if (-not $Started) {
              Write-Output "‚ùå Failed to start process"
              exit 1
            }
            
            $Process.BeginOutputReadLine()
            $Process.BeginErrorReadLine()
            Write-Output "‚úÖ Process started (PID: $($Process.Id))"
            Write-Output ""
            
            # Wait for process to exit or timeout with periodic checks
            $TimeoutSeconds = 120
            $CheckIntervalSeconds = 10
            $ElapsedSeconds = 0
            
            Write-Output "‚è±Ô∏è Waiting for bot to complete (timeout: $TimeoutSeconds seconds)..."
            
            while ($ElapsedSeconds -lt $TimeoutSeconds -and -not $Process.HasExited) {
              Start-Sleep -Seconds $CheckIntervalSeconds
              $ElapsedSeconds += $CheckIntervalSeconds
              
              # Show progress every 30 seconds
              if ($ElapsedSeconds % 30 -eq 0) {
                Write-Output "‚è±Ô∏è Still running... ($ElapsedSeconds / $TimeoutSeconds seconds)"
              }
            }
            
            if (-not $Process.HasExited) {
              Write-Output ""
              Write-Output "‚è±Ô∏è Bot execution timeout after $TimeoutSeconds seconds"
              Write-Output "üõë Stopping bot process..."
              
              # Try graceful shutdown first
              try {
                $Process.CloseMainWindow() | Out-Null
                Start-Sleep -Seconds 3
              } catch {
                Write-Output "‚ö†Ô∏è Could not close main window gracefully"
              }
              
              # Force kill if still running
              if (-not $Process.HasExited) {
                Write-Output "üî® Force stopping process..."
                $Process.Kill($true)
                Start-Sleep -Seconds 2
              }
              
              $ExitCode = -1
            } else {
              $ExitCode = $Process.ExitCode
            }
            
            # Save logs
            $OutputBuilder.ToString() | Out-File -FilePath $LogFile -Encoding utf8
            
            Write-Output ""
            Write-Output "=================================================="
            Write-Output "Bot Execution Summary:"
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Log File: $LogFile"
            Write-Output "=================================================="
            
            # Output last 100 lines of log for GitHub Actions
            Write-Output ""
            Write-Output "üìã Last 100 lines of bot output:"
            Write-Output "=================================================="
            Get-Content $LogFile -Tail 100
            Write-Output "=================================================="
            
            # Set outputs
            "exit_code=$ExitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "log_file=$LogFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            
            if ($ExitCode -eq 0) {
              Write-Output "‚úÖ Bot executed successfully"
            } else {
              Write-Output "‚ùå Bot execution failed with exit code: $ExitCode"
              exit $ExitCode
            }
            
          } catch {
            Write-Output ""
            Write-Output "‚ùå Critical error during bot execution:"
            Write-Output "Error: $($_.Exception.Message)"
            Write-Output "Stack Trace: $($_.Exception.StackTrace)"
            
            # Save error to log
            "CRITICAL ERROR: $($_.Exception.Message)" | Out-File -FilePath $LogFile -Append -Encoding utf8
            $_.Exception.StackTrace | Out-File -FilePath $LogFile -Append -Encoding utf8
            
            exit 1
          }

      - name: "üìä Execution Summary"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üìä Bot Execution Test Summary"
          Write-Output "=================================================="
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_run.outputs.exit_code }}"
          $LogFile = "${{ steps.bot_run.outputs.log_file }}"
          
          if ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output "  Bot executed without errors"
          } elseif ($ExitCode -eq "-1") {
            Write-Output "‚è±Ô∏è Status: TIMEOUT"
            Write-Output "  Bot execution timed out (expected for continuous operation)"
          } else {
            Write-Output "‚ùå Status: FAILED"
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Check logs for errors"
          }
          
          Write-Output ""
          Write-Output "üìù Log Location: $LogFile"
          Write-Output ""
          Write-Output "=================================================="
          
          # Check for specific error patterns in the log
          if (Test-Path $LogFile) {
            Write-Output ""
            Write-Output "üîç Error Analysis:"
            Write-Output "=================================================="
            
            $LogContent = Get-Content $LogFile -Raw
            
            # Check for common error patterns
            $ErrorPatterns = @{
              "NullReferenceException" = "Null reference error detected"
              "InvalidOperationException" = "Invalid operation error detected"
              "ArgumentException" = "Argument error detected"
              "TradingBotParameterProvider" = "Parameter provider error detected"
              "ML parameter provider" = "ML initialization mentioned"
              "CRITICAL ERROR" = "Critical error detected"
              "exit code 1" = "Process exited with error"
            }
            
            foreach ($Pattern in $ErrorPatterns.Keys) {
              if ($LogContent -match $Pattern) {
                Write-Output "  ‚ö†Ô∏è $($ErrorPatterns[$Pattern]): '$Pattern' found in logs"
              }
            }
            
            Write-Output "=================================================="
          }
