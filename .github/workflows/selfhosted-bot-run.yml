name: "üöÄ Bot Continuous Execution"

on:
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Enable DRY_RUN mode (paper trading)'
        required: false
        default: true
        type: boolean
  push:
    branches-ignore:
      - 'main'  # Run on ALL branches except main (agent can test every commit)
  pull_request:
    types: [opened, synchronize, reopened]

permissions:
  contents: read

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"
  DOTNET_VERSION: '8.0.x'

jobs:
  run-bot:
    name: "Run Trading Bot on Self-Hosted Runner"
    runs-on: [self-hosted, Windows, X64]
    timeout-minutes: 7  # Timeout for debugging - agent can see logs after 7 min
    
    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Skip .NET setup - self-hosted runner already has .NET 8.0 installed
      # - name: "üîß Setup .NET SDK"
      #   uses: actions/setup-dotnet@v4
      #   with:
      #     dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "üêç Setup Python Environment"
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: "üì¶ Install Python Dependencies"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üì¶ Installing Python Dependencies"
          Write-Output "=================================================="
          Write-Output ""
          
          # Upgrade pip
          python -m pip install --upgrade pip
          
          # Install project-x-py SDK with all dependencies
          # Note: We only install the core SDK to avoid dependency conflicts
          pip install 'project-x-py[all]>=3.5.0'
          
          # Verify installation
          python -c "import project_x_py; print('‚úÖ project-x-py SDK installed successfully')"
          
          Write-Output ""
          Write-Output "‚úÖ Python dependencies installed"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîß Setup .NET Environment"
        shell: pwsh
        env:
          TOPSTEPX_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          TOPSTEPX_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
          TOPSTEPX_ACCOUNT_ID: ${{ secrets.TOPSTEPX_ACCOUNT_ID }}
          TOPSTEPX_ACCOUNT_NAME: ${{ secrets.TOPSTEPX_ACCOUNT_NAME }}
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET Environment Setup"
          Write-Output "=================================================="
          Write-Output ""
          
          # Check .NET installation
          $DotnetVersion = dotnet --version
          Write-Output "‚úÖ .NET SDK Version: $DotnetVersion"
          Write-Output ""
          Write-Output "üìã .NET SDK Information:"
          dotnet --info
          Write-Output ""
          
          # Check if .env already exists (self-hosted runner)
          if (Test-Path .env) {
            Write-Output "‚úÖ Using existing .env file (self-hosted runner)"
          } else {
            Write-Output "‚ö†Ô∏è No .env file found - creating from secrets"
            # Create .env file from secrets
            @"
          # Trading Mode Configuration
          DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          ENABLE_DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          LIVE_ORDERS=0
          
          # TopstepX API Configuration
          ENABLE_TOPSTEPX=1
          TOPSTEPX_API_BASE=${TOPSTEPX_API_BASE}
          TOPSTEPX_API_KEY=${TOPSTEPX_API_KEY}
          TOPSTEPX_USERNAME=${TOPSTEPX_USERNAME}
          TOPSTEPX_ACCOUNT_ID=${TOPSTEPX_ACCOUNT_ID}
          TOPSTEPX_ACCOUNT_NAME=${TOPSTEPX_ACCOUNT_NAME}
          
          # SDK v3.5.9+ also uses PROJECT_X_* format
          PROJECT_X_API_KEY=${TOPSTEPX_API_KEY}
          PROJECT_X_USERNAME=${TOPSTEPX_USERNAME}
          "@ | Out-File -FilePath .env -Encoding UTF8
            
            Write-Output "‚úÖ Environment configuration created"
            
            # Validate credentials only if we created from secrets
            if ([string]::IsNullOrEmpty($env:TOPSTEPX_API_KEY) -or [string]::IsNullOrEmpty($env:TOPSTEPX_USERNAME) -or [string]::IsNullOrEmpty($env:TOPSTEPX_ACCOUNT_ID)) {
              Write-Output "‚ùå ERROR: Required TopstepX credentials are missing!"
              exit 1
            }
          }
          
          Write-Output "üì¶ Restoring NuGet packages..."
          dotnet restore TopstepX.Bot.sln
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          Write-Output "‚úÖ NuGet restore completed"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Solution"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è Building Trading Bot Solution"
          Write-Output "=================================================="
          Write-Output ""
          
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Output"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç Verifying Build Output"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            $FileSize = (Get-Item $DllPath).Length
            $FileSizeMB = [math]::Round($FileSize / 1MB, 2)
            Write-Output "‚úÖ Build artifacts verified"
            Write-Output "   UnifiedOrchestrator.dll: $FileSizeMB MB"
          } else {
            Write-Output "‚ùå Build artifacts NOT FOUND at: $DllPath"
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Run Trading Bot"
        id: bot_run
        continue-on-error: true
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ Starting Trading Bot"
          Write-Output "=================================================="
          Write-Output ""
          
          # Load environment variables
          if (Test-Path ".env") {
            Get-Content .env | ForEach-Object {
              if ($_ -match '^([^#][^=]+)=(.*)$') {
                [Environment]::SetEnvironmentVariable($matches[1], $matches[2])
              }
            }
          }
          
          # Override with DRY_RUN from input
          $env:DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          Write-Output "‚ö†Ô∏è DRY_RUN mode: ${{ github.event.inputs.dry_run }}"
          Write-Output ""
          
          # Create log capture directory BEFORE starting adapter
          $LogDir = "$env:TEMP/qbot-bot-run-logs"
          if (-not (Test-Path $LogDir)) {
            New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
          }
          
          $Timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          
          # Start Python TopstepX Adapter
          Write-Output "üêç Starting Python TopstepX Adapter..."
          $PythonAdapterPath = "src/adapters/topstep_x_adapter.py"
          
          if (-not (Test-Path $PythonAdapterPath)) {
            Write-Output "‚ùå ERROR: Python adapter not found at $PythonAdapterPath"
            exit 1
          }
          
          # Find Python executable
          $PythonExe = $null
          
          # Try to find Python in PATH first
          $PythonExe = (Get-Command python -ErrorAction SilentlyContinue).Source
          if (-not $PythonExe) {
            $PythonExe = (Get-Command python3 -ErrorAction SilentlyContinue).Source
          }
          
          # If not in PATH, try common installation locations
          if (-not $PythonExe) {
            $CommonPaths = @(
              "$env:LOCALAPPDATA\Programs\Python\Python312\python.exe",
              "$env:LOCALAPPDATA\Programs\Python\Python311\python.exe",
              "$env:LOCALAPPDATA\Programs\Python\Python310\python.exe",
              "C:\Python312\python.exe",
              "C:\Python311\python.exe",
              "C:\Python310\python.exe"
            )
            foreach ($Path in $CommonPaths) {
              if (Test-Path $Path) {
                $PythonExe = $Path
                break
              }
            }
          }
          
          if (-not $PythonExe) {
            Write-Output "‚ùå ERROR: Python executable not found in PATH or common locations"
            Write-Output "Checked locations:"
            Write-Output "  - PATH (python, python3)"
            Write-Output "  - $env:LOCALAPPDATA\Programs\Python\Python31x\python.exe"
            Write-Output "  - C:\Python31x\python.exe"
            exit 1
          }
          Write-Output "Using Python: $PythonExe"
          
          $AdapterLogFile = "$LogDir/adapter-$Timestamp.log"
          $AdapterProcess = Start-Process -FilePath $PythonExe `
            -ArgumentList $PythonAdapterPath `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $AdapterLogFile `
            -RedirectStandardError "$LogDir/adapter-error-$Timestamp.log"
          
          $AdapterPID = $AdapterProcess.Id
          Write-Output "‚úÖ Python adapter started (PID: $AdapterPID)"
          Write-Output "üìù Adapter logs: $AdapterLogFile"
          Write-Output ""
          
          # Wait for adapter to initialize (check for port 8765 to be listening)
          Write-Output "‚è≥ Waiting for adapter to initialize..."
          $AdapterReady = $false
          for ($i = 0; $i -lt 30; $i++) {
            Start-Sleep -Seconds 1
            $Connection = Test-NetConnection -ComputerName localhost -Port 8765 -InformationLevel Quiet -WarningAction SilentlyContinue
            if ($Connection) {
              $AdapterReady = $true
              Write-Output "‚úÖ Adapter ready on port 8765 (after $i seconds)"
              break
            }
          }
          
          if (-not $AdapterReady) {
            Write-Output "‚ö†Ô∏è WARNING: Adapter may not be ready after 30 seconds"
            Write-Output "üìã Last 20 lines of adapter log:"
            Get-Content $AdapterLogFile -Tail 20 -ErrorAction SilentlyContinue
          }
          Write-Output ""
          
          # Variables already defined above (before adapter startup)
          $LogFile = "$LogDir/bot-run-$Timestamp.log"
          
          Write-Output "üìù Bot output will be captured to: $LogFile"
          Write-Output ""
          Write-Output "Starting bot execution..."
          Write-Output "=================================================="
          Write-Output ""
          
          # Run the bot with all output streaming directly to console
          # This allows GitHub Actions to capture ALL logs (ML, RL, strategies, etc.)
          Write-Output "üöÄ Starting bot with live log streaming..."
          Write-Output "üìä All logs will be visible in GitHub Actions console"
          Write-Output ""
          
          $DotnetPath = "C:\Program Files\dotnet\dotnet.exe"
          
          # Run directly WITHOUT redirection so all logs stream to GitHub Actions
          & $DotnetPath run --project src/UnifiedOrchestrator/UnifiedOrchestrator.csproj --no-build -c Release
          
          $ExitCode = $LASTEXITCODE
          Write-Output ""
          Write-Output "ÔøΩ Bot process exited with code: $ExitCode"
          
          # Cleanup: Stop Python adapter
          Write-Output ""
          Write-Output "üßπ Cleaning up Python adapter..."
          $AdapterProcess = Get-Process -Id $AdapterPID -ErrorAction SilentlyContinue
          if ($AdapterProcess) {
            Stop-Process -Id $AdapterPID -Force -ErrorAction SilentlyContinue
            Write-Output "‚úÖ Python adapter stopped"
          } else {
            Write-Output "‚ö†Ô∏è Python adapter already stopped"
          }
          
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "Bot Execution Summary:"
          Write-Output "  Exit Code: $(if ($ExitCode) { $ExitCode } else { 0 })"
          Write-Output "  All logs were streamed directly to GitHub Actions console above"
          Write-Output "=================================================="
          
          # Set outputs
          $ExitCodeValue = if ($ExitCode) { $ExitCode } else { 0 }
          "exit_code=$ExitCodeValue" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
          
          if ($ExitCodeValue -eq 0) {
            Write-Output "‚úÖ Bot executed successfully"
          } else {
            Write-Output "‚ùå Bot execution failed with exit code: $ExitCodeValue"
            exit $ExitCodeValue
          }

      - name: "üìä Execution Summary"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üìä Bot Execution Test Summary"
          Write-Output "=================================================="
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_run.outputs.exit_code }}"
          $LogFile = "${{ steps.bot_run.outputs.log_file }}"
          
          if ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output "  Bot executed without errors"
          } elseif ($ExitCode -eq "-1") {
            Write-Output "‚è±Ô∏è Status: TIMEOUT"
            Write-Output "  Bot execution timed out (expected for continuous operation)"
          } else {
            Write-Output "‚ùå Status: FAILED"
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Check logs for errors"
          }
          
          Write-Output ""
          Write-Output "üìù Log Location: $LogFile"
          Write-Output ""
          Write-Output "=================================================="
