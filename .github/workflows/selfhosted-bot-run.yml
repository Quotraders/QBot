name: "üöÄ Bot Execution Test"

on:
  workflow_dispatch:
    inputs:
      timeout_minutes:
        description: 'Bot execution timeout (minutes)'
        required: false
        default: '5'
        type: string
      dry_run:
        description: 'Enable DRY_RUN mode (paper trading)'
        required: false
        default: true
        type: boolean

permissions:
  contents: read

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"
  DOTNET_VERSION: '8.0.x'

jobs:
  run-bot:
    name: "Run Trading Bot on Self-Hosted Runner"
    runs-on: [self-hosted, Windows, X64]
    timeout-minutes: ${{ fromJSON(github.event.inputs.timeout_minutes || '5') }}
    
    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Skip .NET setup - self-hosted runner already has .NET 8.0 installed
      # - name: "üîß Setup .NET SDK"
      #   uses: actions/setup-dotnet@v4
      #   with:
      #     dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "üîß Setup .NET Environment"
        shell: pwsh
        env:
          TOPSTEPX_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          TOPSTEPX_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
          TOPSTEPX_ACCOUNT_ID: ${{ secrets.TOPSTEPX_ACCOUNT_ID }}
          TOPSTEPX_ACCOUNT_NAME: ${{ secrets.TOPSTEPX_ACCOUNT_NAME }}
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET Environment Setup"
          Write-Output "=================================================="
          Write-Output ""
          
          # Check .NET installation
          $DotnetVersion = dotnet --version
          Write-Output "‚úÖ .NET SDK Version: $DotnetVersion"
          Write-Output ""
          Write-Output "üìã .NET SDK Information:"
          dotnet --info
          Write-Output ""
          
          # Check if .env already exists (self-hosted runner)
          if (Test-Path .env) {
            Write-Output "‚úÖ Using existing .env file (self-hosted runner)"
          } else {
            Write-Output "‚ö†Ô∏è No .env file found - creating from secrets"
            # Create .env file from secrets
            @"
          # Trading Mode Configuration
          DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          ENABLE_DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          LIVE_ORDERS=0
          
          # TopstepX API Configuration
          ENABLE_TOPSTEPX=1
          TOPSTEPX_API_BASE=${TOPSTEPX_API_BASE}
          TOPSTEPX_API_KEY=${TOPSTEPX_API_KEY}
          TOPSTEPX_USERNAME=${TOPSTEPX_USERNAME}
          TOPSTEPX_ACCOUNT_ID=${TOPSTEPX_ACCOUNT_ID}
          TOPSTEPX_ACCOUNT_NAME=${TOPSTEPX_ACCOUNT_NAME}
          "@ | Out-File -FilePath .env -Encoding UTF8
            
            Write-Output "‚úÖ Environment configuration created"
            
            # Validate credentials only if we created from secrets
            if ([string]::IsNullOrEmpty($env:TOPSTEPX_API_KEY) -or [string]::IsNullOrEmpty($env:TOPSTEPX_USERNAME) -or [string]::IsNullOrEmpty($env:TOPSTEPX_ACCOUNT_ID)) {
              Write-Output "‚ùå ERROR: Required TopstepX credentials are missing!"
              exit 1
            }
          }
          
          Write-Output "üì¶ Restoring NuGet packages..."
          dotnet restore TopstepX.Bot.sln
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          Write-Output "‚úÖ NuGet restore completed"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Solution"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è Building Trading Bot Solution"
          Write-Output "=================================================="
          Write-Output ""
          
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Output"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç Verifying Build Output"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            $FileSize = (Get-Item $DllPath).Length
            $FileSizeMB = [math]::Round($FileSize / 1MB, 2)
            Write-Output "‚úÖ Build artifacts verified"
            Write-Output "   UnifiedOrchestrator.dll: $FileSizeMB MB"
          } else {
            Write-Output "‚ùå Build artifacts NOT FOUND at: $DllPath"
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Run Trading Bot"
        id: bot_run
        continue-on-error: true
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ Starting Trading Bot"
          Write-Output "=================================================="
          Write-Output ""
          
          # Load environment variables
          if (Test-Path ".env") {
            Get-Content .env | ForEach-Object {
              if ($_ -match '^([^#][^=]+)=(.*)$') {
                [Environment]::SetEnvironmentVariable($matches[1], $matches[2])
              }
            }
          }
          
          # Override with DRY_RUN from input
          $env:DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          Write-Output "‚ö†Ô∏è DRY_RUN mode: ${{ github.event.inputs.dry_run }}"
          Write-Output ""
          
          # Create log capture directory BEFORE starting adapter
          $LogDir = "$env:TEMP/qbot-bot-run-logs"
          if (-not (Test-Path $LogDir)) {
            New-Item -ItemType Directory -Path $LogDir -Force | Out-Null
          }
          
          $Timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          
          # Start Python TopstepX Adapter
          Write-Output "üêç Starting Python TopstepX Adapter..."
          $PythonAdapterPath = "src/adapters/topstep_x_adapter.py"
          
          if (-not (Test-Path $PythonAdapterPath)) {
            Write-Output "‚ùå ERROR: Python adapter not found at $PythonAdapterPath"
            exit 1
          }
          
          $AdapterLogFile = "$LogDir/adapter-$Timestamp.log"
          $AdapterProcess = Start-Process -FilePath "python" `
            -ArgumentList $PythonAdapterPath `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $AdapterLogFile `
            -RedirectStandardError "$LogDir/adapter-error-$Timestamp.log"
          
          $AdapterPID = $AdapterProcess.Id
          Write-Output "‚úÖ Python adapter started (PID: $AdapterPID)"
          Write-Output "üìù Adapter logs: $AdapterLogFile"
          Write-Output ""
          
          # Wait for adapter to initialize (check for port 8765 to be listening)
          Write-Output "‚è≥ Waiting for adapter to initialize..."
          $AdapterReady = $false
          for ($i = 0; $i -lt 30; $i++) {
            Start-Sleep -Seconds 1
            $Connection = Test-NetConnection -ComputerName localhost -Port 8765 -InformationLevel Quiet -WarningAction SilentlyContinue
            if ($Connection) {
              $AdapterReady = $true
              Write-Output "‚úÖ Adapter ready on port 8765 (after $i seconds)"
              break
            }
          }
          
          if (-not $AdapterReady) {
            Write-Output "‚ö†Ô∏è WARNING: Adapter may not be ready after 30 seconds"
            Write-Output "üìã Last 20 lines of adapter log:"
            Get-Content $AdapterLogFile -Tail 20 -ErrorAction SilentlyContinue
          }
          Write-Output ""
          
          # Variables already defined above (before adapter startup)
          $LogFile = "$LogDir/bot-run-$Timestamp.log"
          
          Write-Output "üìù Bot output will be captured to: $LogFile"
          Write-Output ""
          Write-Output "Starting bot execution..."
          Write-Output "=================================================="
          Write-Output ""
          
          # Run the bot and capture all output
          $DotnetPath = "C:\Program Files\dotnet\dotnet.exe"
          $ProcessInfo = Start-Process -FilePath $DotnetPath `
            -ArgumentList "run", "--project", "src/UnifiedOrchestrator/UnifiedOrchestrator.csproj", "--no-build", "-c", "Release" `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $LogFile `
            -RedirectStandardError "$LogDir/bot-error-$Timestamp.log"
          
          $BotPID = $ProcessInfo.Id
          Write-Output "‚úÖ Process started (PID: $BotPID)"
          Write-Output ""
          
          # Wait for process to exit or timeout
          $TimeoutSeconds = 120
          $CheckInterval = 10
          $Elapsed = 0
          
          Write-Output "‚è±Ô∏è Waiting for bot to complete (timeout: $TimeoutSeconds seconds)..."
          
          $ExitCode = $null
          while ($Elapsed -lt $TimeoutSeconds) {
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if (-not $BotProcess) {
              $ExitCode = $ProcessInfo.ExitCode
              break
            }
            
            Start-Sleep -Seconds $CheckInterval
            $Elapsed += $CheckInterval
            
            # Show progress every 30 seconds
            if (($Elapsed % 30) -eq 0) {
              Write-Output "‚è±Ô∏è Still running... ($Elapsed / $TimeoutSeconds seconds)"
            }
          }
          
          # Stop if timeout reached
          $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
          if ($BotProcess) {
            Write-Output ""
            Write-Output "‚è±Ô∏è Bot execution timeout after $TimeoutSeconds seconds"
            Write-Output "üõë Stopping bot process..."
            
            Stop-Process -Id $BotPID -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 3
            
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if ($BotProcess) {
              Write-Output "üî® Force stopping process..."
              Stop-Process -Id $BotPID -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 2
            }
            
            $ExitCode = -1
          }
          
          # Cleanup: Stop Python adapter
          Write-Output ""
          Write-Output "üßπ Cleaning up Python adapter..."
          $AdapterProcess = Get-Process -Id $AdapterPID -ErrorAction SilentlyContinue
          if ($AdapterProcess) {
            Stop-Process -Id $AdapterPID -Force -ErrorAction SilentlyContinue
            Write-Output "‚úÖ Python adapter stopped"
          } else {
            Write-Output "‚ö†Ô∏è Python adapter already stopped"
          }
          
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "Bot Execution Summary:"
          Write-Output "  Exit Code: $(if ($ExitCode) { $ExitCode } else { 0 })"
          Write-Output "  Log File: $LogFile"
          Write-Output "  Adapter Log: $AdapterLogFile"
          Write-Output "=================================================="
          
          # Output last 100 lines of bot log
          Write-Output ""
          Write-Output "üìã Last 100 lines of bot output:"
          Write-Output "=================================================="
          Get-Content $LogFile -Tail 100
          Write-Output "=================================================="
          
          # Output last 50 lines of adapter log
          Write-Output ""
          Write-Output "üêç Last 50 lines of adapter output:"
          Write-Output "=================================================="
          Get-Content $AdapterLogFile -Tail 50 -ErrorAction SilentlyContinue
          Write-Output "=================================================="
          
          # Set outputs
          $ExitCodeValue = if ($ExitCode) { $ExitCode } else { 0 }
          "exit_code=$ExitCodeValue" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
          "log_file=$LogFile" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
          
          if ($ExitCodeValue -eq 0) {
            Write-Output "‚úÖ Bot executed successfully"
          } else {
            Write-Output "‚ùå Bot execution failed with exit code: $ExitCodeValue"
            exit $ExitCodeValue
          }

      - name: "üìä Execution Summary"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üìä Bot Execution Test Summary"
          Write-Output "=================================================="
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_run.outputs.exit_code }}"
          $LogFile = "${{ steps.bot_run.outputs.log_file }}"
          
          if ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output "  Bot executed without errors"
          } elseif ($ExitCode -eq "-1") {
            Write-Output "‚è±Ô∏è Status: TIMEOUT"
            Write-Output "  Bot execution timed out (expected for continuous operation)"
          } else {
            Write-Output "‚ùå Status: FAILED"
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Check logs for errors"
          }
          
          Write-Output ""
          Write-Output "üìù Log Location: $LogFile"
          Write-Output ""
          Write-Output "=================================================="
