name: "ü§ñ Bot Launch Diagnostics"

on:
  workflow_dispatch:
    inputs:
      runtime_minutes:
        description: 'Bot runtime duration (minutes)'
        required: false
        default: '5'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'
      capture_detailed_logs:
        description: 'Capture detailed verbose logs'
        required: false
        default: true
        type: boolean
      dry_run:
        description: 'Enable DRY_RUN mode (paper trading)'
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  actions: write

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"
  ARTIFACTS_DIR: "bot-diagnostics"
  DOTNET_VERSION: '8.0.x'

jobs:
  bot-launch-diagnostics:
    name: "Launch Bot with Full Diagnostics Capture"
    runs-on: [self-hosted, windows, x64]
    timeout-minutes: 40  # Covers max runtime (30min) + startup/shutdown buffer
    
    steps:
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: "üîß Setup .NET SDK"
        uses: actions/setup-dotnet@v4
        with:
          dotnet-version: ${{ env.DOTNET_VERSION }}

      - name: "üîç Pre-Launch Environment Validation"
        id: env_validation
        shell: pwsh
        env:
          TOPSTEPX_API_KEY: ${{ secrets.TOPSTEPX_API_KEY }}
          TOPSTEPX_USERNAME: ${{ secrets.TOPSTEPX_USERNAME }}
          TOPSTEPX_ACCOUNT_ID: ${{ secrets.TOPSTEPX_ACCOUNT_ID }}
          TOPSTEPX_ACCOUNT_NAME: ${{ secrets.TOPSTEPX_ACCOUNT_NAME }}
        run: |
          Write-Output "=================================================="
          Write-Output "üîç PRE-LAUNCH ENVIRONMENT VALIDATION"
          Write-Output "=================================================="
          Write-Output ""
          
          # Create diagnostics directory
          $DiagDir = "$env:RUNNER_TEMP/${{ env.ARTIFACTS_DIR }}"
          if (-not (Test-Path $DiagDir)) {
            New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
          }
          Write-Output "üìÅ Diagnostics directory: $DiagDir"
          Write-Output ""
          
          # System Information
          Write-Output "üñ•Ô∏è System Information:"
          Write-Output "  Runner: Self-hosted Windows"
          Write-Output "  OS: ${{ runner.os }}"
          Write-Output "  Architecture: ${{ runner.arch }}"
          Write-Output "  Hostname: $env:COMPUTERNAME"
          Write-Output "  User: $env:USERNAME"
          Write-Output "  Working Directory: $(Get-Location)"
          Write-Output "  Temp Directory: $DiagDir"
          Write-Output ""
          
          # .NET Environment
          Write-Output "‚öôÔ∏è .NET Environment:"
          $DotnetVersion = dotnet --version
          Write-Output "  ‚úÖ .NET SDK: $DotnetVersion"
          Write-Output ""
          Write-Output "üìã .NET SDK Information:"
          dotnet --info
          Write-Output ""
          
          # Validate TopstepX credentials
          Write-Output "üìÑ Configuration:"
          Write-Output "  Validating TopstepX credentials..."
          
          if ([string]::IsNullOrEmpty($env:TOPSTEPX_API_KEY) -or [string]::IsNullOrEmpty($env:TOPSTEPX_USERNAME) -or [string]::IsNullOrEmpty($env:TOPSTEPX_ACCOUNT_ID)) {
            Write-Output "  ‚ùå ERROR: Required TopstepX credentials are missing!"
            Write-Output ""
            Write-Output "  Please ensure the following secrets are set in GitHub repository settings:"
            Write-Output "    - TOPSTEPX_API_KEY"
            Write-Output "    - TOPSTEPX_USERNAME"
            Write-Output "    - TOPSTEPX_ACCOUNT_ID"
            Write-Output "    - TOPSTEPX_ACCOUNT_NAME (optional)"
            Write-Output ""
            exit 1
          }
          
          Write-Output "  ‚úÖ TopstepX credentials: Validated"
          Write-Output ""
          
          # Create .env file from secrets
          @'
          # ===================================
          # GITHUB CLOUD LEARNING & RL
          # ===================================
          CLOUD_PROVIDER=github
          RL_ENABLED=1
          GITHUB_CLOUD_LEARNING=1
          
          # ===================================
          # AUTO-LEARNING & PROMOTION CONFIG
          # ===================================
          AUTO_PROMOTION_ENABLED=1
          AUTO_LEARNING_ENABLED=1
          CHALLENGER_AUTO_APPROVE=1
          REQUIRE_MANUAL_PROMOTION=0
          MIN_SHADOW_TEST_TRADES=50
          MIN_SHADOW_TEST_SESSIONS=5
          PROMOTION_CONFIDENCE_THRESHOLD=0.65
          ROLLBACK_ON_PERFORMANCE_DECLINE=1
          
          # ===================================
          # TRADING MODE CONFIGURATION
          # ===================================
          DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          ENABLE_DRY_RUN=${{ github.event.inputs.dry_run == 'true' && '1' || '0' }}
          LIVE_ORDERS=0
          INSTANT_ALLOW_LIVE=0
          
          # ===================================
          # TOPSTEPX API CONFIGURATION
          # ===================================
          ENABLE_TOPSTEPX=1
          TOPSTEPX_API_BASE=https://api.topstepx.com
          TOPSTEPX_RTC_BASE=https://rtc.topstepx.com
          TOPSTEPX_ADAPTER_MODE=persistent
          TOPSTEPX_API_KEY=${TOPSTEPX_API_KEY}
          TOPSTEPX_USERNAME=${TOPSTEPX_USERNAME}
          TOPSTEPX_ACCOUNT_ID=${TOPSTEPX_ACCOUNT_ID}
          TOPSTEPX_ACCOUNT_NAME=${TOPSTEPX_ACCOUNT_NAME}
          TOPSTEPX_EVAL_ES_ID=CON.F.US.EP.Z25
          TOPSTEPX_EVAL_NQ_ID=CON.F.US.ENQ.Z25
          FORCE_TOPSTEPX_CONNECTION=true
          
          # ===================================
          # LOGGING CONFIGURATION
          # ===================================
          LOG_LEVEL=${{ github.event.inputs.capture_detailed_logs == 'true' && 'Debug' || 'Information' }}
          LOGGING__LOGLEVEL__DEFAULT=${{ github.event.inputs.capture_detailed_logs == 'true' && 'Debug' || 'Information' }}
          LOGGING__LOGLEVEL__SYSTEM=Information
          LOGGING__LOGLEVEL__MICROSOFT=Warning
          
          # ===================================
          # ENHANCED LEARNING CONFIGURATION
          # ===================================
          ENHANCED_LEARNING_ENABLED=1
          MODEL_REGISTRY_ENABLED=1
          CANARY_WATCHDOG_ENABLED=1
          ADAPTIVE_INTELLIGENCE_ENABLED=1
          PROMOTE_TUNER=1
          '@ | Out-File -FilePath .env -Encoding UTF8
          
          Write-Output "  ‚úÖ .env file: Created from secrets"
          Write-Output ""
          
          # Save system info to JSON
          $SystemInfoJson = @"
          {
            "timestamp": "$(Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ" -AsUTC)",
            "runner": {
              "type": "Self-hosted Windows",
              "os": "${{ runner.os }}",
              "arch": "${{ runner.arch }}",
              "hostname": "$env:COMPUTERNAME",
              "user": "$env:USERNAME"
            },
            "dotnet": {
              "version": "$DotnetVersion"
            },
            "workflow": {
              "name": "${{ github.workflow }}",
              "run_id": "${{ github.run_id }}",
              "run_number": "${{ github.run_number }}",
              "triggered_by": "${{ github.actor }}"
            }
          }
          "@
          
          $SystemInfoJson | Out-File -FilePath "$DiagDir/system-info.json" -Encoding UTF8
          
          Write-Output "üíæ System info saved to: system-info.json"
          Write-Output ""
          Write-Output "=================================================="
          
          # Export diagnostics directory for later steps
          "diag_dir=$DiagDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8

      - name: "üîß Setup .NET and Restore Packages"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET SETUP AND PACKAGE RESTORE"
          Write-Output "=================================================="
          Write-Output ""
          
          Write-Output "üì¶ Restoring NuGet packages..."
          $RestoreStart = Get-Date
          
          dotnet restore TopstepX.Bot.sln --verbosity minimal
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          $RestoreEnd = Get-Date
          $RestoreDuration = ($RestoreEnd - $RestoreStart).TotalSeconds
          
          Write-Output "‚úÖ NuGet restore completed in $([math]::Round($RestoreDuration))s"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Trading Bot"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è BUILDING TRADING BOT"
          Write-Output "=================================================="
          Write-Output ""
          
          $BuildStart = Get-Date
          
          # Build UnifiedOrchestrator
          Write-Output "üî® Building UnifiedOrchestrator..."
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          $BuildEnd = Get-Date
          $BuildDuration = ($BuildEnd - $BuildStart).TotalSeconds
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully in $([math]::Round($BuildDuration))s"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Artifacts"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç VERIFYING BUILD ARTIFACTS"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            $FileSize = (Get-Item $DllPath).Length
            $FileSizeMB = [math]::Round($FileSize / 1MB, 2)
            Write-Output "‚úÖ UnifiedOrchestrator.dll found"
            Write-Output "   Size: $FileSizeMB MB"
            Write-Output "   Path: $DllPath"
          } else {
            Write-Output "‚ùå UnifiedOrchestrator.dll NOT FOUND"
            Write-Output "   Expected path: $DllPath"
            Write-Output ""
            Write-Output "üìÅ Listing build output directory:"
            Get-ChildItem "src/UnifiedOrchestrator/bin/Release/net8.0" -ErrorAction SilentlyContinue | Format-Table
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Launch Bot with Full Diagnostics"
        id: bot_launch
        continue-on-error: true
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ LAUNCHING TRADING BOT WITH DIAGNOSTICS"
          Write-Output "=================================================="
          Write-Output ""
          
          # Load environment variables from .env
          if (Test-Path ".env") {
            Write-Output "üì• Loading environment variables from .env..."
            Get-Content .env | ForEach-Object {
              if ($_ -match '^([^#][^=]+)=(.*)$') {
                [Environment]::SetEnvironmentVariable($matches[1], $matches[2])
              }
            }
            Write-Output "‚úÖ Environment variables loaded"
            Write-Output ""
          }
          
          $DiagDir = "${{ steps.env_validation.outputs.diag_dir }}"
          if ([string]::IsNullOrEmpty($DiagDir)) {
            $DiagDir = "$env:RUNNER_TEMP/${{ env.ARTIFACTS_DIR }}"
            if (-not (Test-Path $DiagDir)) {
              New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
            }
            Write-Output "‚ö†Ô∏è Using fallback diagnostics directory: $DiagDir"
          }
          $Timestamp = Get-Date -Format "yyyy-MM-dd_HH-mm-ss"
          
          # Create log files
          $ConsoleLogFile = "$DiagDir/console-output-$Timestamp.log"
          $ErrorLogFile = "$DiagDir/error-output-$Timestamp.log"
          $StructuredLogFile = "$DiagDir/structured-log-$Timestamp.json"
          
          Write-Output "üìù Log files:"
          Write-Output "  Console: console-output-$Timestamp.log"
          Write-Output "  Errors: error-output-$Timestamp.log"
          Write-Output "  Structured: structured-log-$Timestamp.json"
          Write-Output ""
          
          # Override with DRY_RUN for safety if configured
          $env:DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          $env:ENABLE_DRY_RUN = if ("${{ github.event.inputs.dry_run }}" -eq "true") { "1" } else { "0" }
          Write-Output "‚ö†Ô∏è DRY_RUN mode: ${{ github.event.inputs.dry_run }}"
          Write-Output ""
          
          # Prepare bot launch
          Write-Output "üéØ Bot configuration:"
          Write-Output "  Runtime: ${{ github.event.inputs.runtime_minutes || '5' }} minutes"
          Write-Output "  Detailed logging: ${{ github.event.inputs.capture_detailed_logs || 'true' }}"
          Write-Output ""
          Write-Output "=================================================="
          Write-Output ""
          Write-Output "ü§ñ STARTING BOT..."
          Write-Output ""
          
          # Capture startup timestamp
          $StartTime = Get-Date
          
          # Launch bot with output capture
          Write-Output "üîÑ Starting process..."
          $ProcessInfo = Start-Process -FilePath "dotnet" `
            -ArgumentList "run", "--project", "src/UnifiedOrchestrator/UnifiedOrchestrator.csproj", "--no-build", "-c", "Release" `
            -NoNewWindow `
            -PassThru `
            -RedirectStandardOutput $ConsoleLogFile `
            -RedirectStandardError $ErrorLogFile
          
          $BotPID = $ProcessInfo.Id
          Write-Output "‚úÖ Process started (PID: $BotPID)"
          
          # Give process a few seconds to initialize
          Write-Output "‚è≥ Waiting for initialization..."
          Start-Sleep -Seconds 5
          
          # Check if process crashed immediately
          $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
          if (-not $BotProcess) {
            $ExitCode = $ProcessInfo.ExitCode
            Write-Output ""
            Write-Output "‚ùå Process exited immediately with code: $ExitCode"
            Write-Output ""
            Write-Output "This usually indicates a startup failure. Check the logs for errors."
            
            # Show first 100 lines of output for debugging
            Write-Output "üìã First 100 lines of output:"
            Write-Output "=================================================="
            Get-Content $ConsoleLogFile -Head 100 -ErrorAction SilentlyContinue
            Write-Output "=================================================="
            
            # Also show errors
            if (Test-Path $ErrorLogFile) {
              Write-Output ""
              Write-Output "üìã Error output:"
              Write-Output "=================================================="
              Get-Content $ErrorLogFile
              Write-Output "=================================================="
            }
            
            exit 1
          }
          
          Write-Output ""
          Write-Output "‚è±Ô∏è Bot is running... (will run for ${{ github.event.inputs.runtime_minutes || '5' }} minutes)"
          Write-Output ""
          
          # Wait for specified duration with periodic checks
          $RuntimeMinutes = [int]"${{ github.event.inputs.runtime_minutes || '5' }}"
          $TimeoutSeconds = $RuntimeMinutes * 60
          $CheckIntervalSeconds = 10
          $ElapsedSeconds = 0
          
          $ExitCode = $null
          $ExitReason = $null
          
          while ($ElapsedSeconds -lt $TimeoutSeconds) {
            # Check if process is still running
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if (-not $BotProcess) {
              $ExitCode = $ProcessInfo.ExitCode
              Write-Output ""
              Write-Output "‚ö†Ô∏è Bot process exited (exit code: $ExitCode)"
              
              # Save exit code to output
              "exit_code=$ExitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
              "exit_reason=exited" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
              $ExitReason = "exited"
              
              break
            }
            
            # Wait and update progress
            Start-Sleep -Seconds $CheckIntervalSeconds
            $ElapsedSeconds += $CheckIntervalSeconds
            
            # Show progress every 30 seconds
            if (($ElapsedSeconds % 30) -eq 0) {
              $RemainingMinutes = [math]::Round(($TimeoutSeconds - $ElapsedSeconds) / 60, 1)
              Write-Output "‚è±Ô∏è Still running... ($RemainingMinutes minutes remaining)"
            }
          }
          
          $EndTime = Get-Date
          $ActualRuntime = ($EndTime - $StartTime).TotalSeconds
          
          # Stop process if still running
          $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
          if ($BotProcess) {
            Write-Output ""
            Write-Output "‚è±Ô∏è Runtime limit reached ($RuntimeMinutes minutes)"
            Write-Output "üõë Stopping bot gracefully..."
            
            # Try graceful shutdown first
            Stop-Process -Id $BotPID -ErrorAction SilentlyContinue
            Start-Sleep -Seconds 5
            
            # Force kill if still running
            $BotProcess = Get-Process -Id $BotPID -ErrorAction SilentlyContinue
            if ($BotProcess) {
              Write-Output "üî® Force stopping..."
              Stop-Process -Id $BotPID -Force -ErrorAction SilentlyContinue
              Start-Sleep -Seconds 2
            }
            
            $ExitCode = 0  # Timeout is expected, not an error
            $ExitReason = "timeout"
            
            "exit_code=0" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
            "exit_reason=timeout" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8
            
            Write-Output "‚úÖ Bot stopped"
          }
          
          # Create structured log
          $StructuredLogJson = @"
          {
            "launch_timestamp": "$($StartTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ"))",
            "end_timestamp": "$($EndTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ"))",
            "runtime_minutes": "${{ github.event.inputs.runtime_minutes || '5' }}",
            "actual_runtime_seconds": $([math]::Round($ActualRuntime)),
            "dry_run_enabled": $(if ("${{ github.event.inputs.dry_run }}" -eq "true") { "true" } else { "false" }),
            "exit_code": $(if ($ExitCode) { $ExitCode } else { 0 }),
            "exit_reason": "$(if ($ExitReason) { $ExitReason } else { 'timeout' })",
            "workflow_run_id": "${{ github.run_id }}"
          }
          "@
          
          $StructuredLogJson | Out-File -FilePath $StructuredLogFile -Encoding UTF8
          
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "üìä BOT EXECUTION SUMMARY"
          Write-Output "=================================================="
          Write-Output "  Exit Code: $(if ($ExitCode) { $ExitCode } else { 0 })"
          Write-Output "  Exit Reason: $(if ($ExitReason) { $ExitReason } else { 'timeout' })"
          Write-Output "  Actual Runtime: $([math]::Round($ActualRuntime))s"
          Write-Output "=================================================="
          Write-Output ""
          
          # Output last 150 lines for GitHub Actions UI
          Write-Output "üìã LAST 150 LINES OF OUTPUT:"
          Write-Output "=================================================="
          Get-Content $ConsoleLogFile -Tail 150 -ErrorAction SilentlyContinue
          Write-Output "=================================================="
          Write-Output ""
          
          # Set runtime output
          "runtime_seconds=$([math]::Round($ActualRuntime))" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding UTF8

      - name: "üì¶ Package Diagnostics Artifacts"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üì¶ PACKAGING DIAGNOSTICS ARTIFACTS"
          Write-Output "=================================================="
          Write-Output ""
          
          $DiagDir = "${{ steps.env_validation.outputs.diag_dir }}"
          if ([string]::IsNullOrEmpty($DiagDir)) {
            $DiagDir = "$env:RUNNER_TEMP/${{ env.ARTIFACTS_DIR }}"
            Write-Output "‚ö†Ô∏è Using fallback diagnostics directory: $DiagDir"
          }
          
          # Check if directory exists and has content
          if (-not (Test-Path $DiagDir)) {
            Write-Output "‚ö†Ô∏è Diagnostics directory not found: $DiagDir"
            Write-Output "   This may indicate the workflow failed early."
            New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
            "Workflow failed during early stage - no diagnostics captured" | Out-File -FilePath "$DiagDir/workflow-failure-note.txt" -Encoding UTF8
            return
          }
          
          # List all captured files
          Write-Output "üìÅ Captured artifacts:"
          Get-ChildItem $DiagDir | ForEach-Object {
            $SizeKB = [math]::Round($_.Length / 1KB, 2)
            Write-Output "  üìÑ $($_.Name) ($SizeKB KB)"
          }
          
          Write-Output ""
          Write-Output "‚úÖ Diagnostics packaged and ready for upload"
          Write-Output ""
          Write-Output "=================================================="

      - name: "‚¨ÜÔ∏è Upload Diagnostics Artifacts"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bot-diagnostics-run-${{ github.run_number }}
          path: ${{ steps.env_validation.outputs.diag_dir || format('{0}/{1}', runner.temp, env.ARTIFACTS_DIR) }}
          retention-days: 30
          compression-level: 6

      - name: "üìä Final Execution Report"
        if: always()
        shell: pwsh
        run: |
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "üìä BOT LAUNCH DIAGNOSTICS - FINAL REPORT"
          Write-Output "=================================================="
          Write-Output ""
          Write-Output "ü§ñ Bot Launch Summary:"
          Write-Output "  Workflow: ${{ github.workflow }}"
          Write-Output "  Run ID: ${{ github.run_id }}"
          Write-Output "  Run Number: ${{ github.run_number }}"
          Write-Output "  Triggered By: ${{ github.actor }}"
          Write-Output ""
          Write-Output "üìä Execution Results:"
          Write-Output "  Exit Code: ${{ steps.bot_launch.outputs.exit_code || 'N/A' }}"
          Write-Output "  Exit Reason: ${{ steps.bot_launch.outputs.exit_reason || 'N/A' }}"
          Write-Output "  Runtime: ${{ steps.bot_launch.outputs.runtime_seconds || 'N/A' }}s"
          Write-Output ""
          Write-Output "üì¶ Artifacts:"
          Write-Output "  Name: bot-diagnostics-run-${{ github.run_number }}"
          Write-Output "  Location: GitHub Actions Artifacts (30 day retention)"
          Write-Output "  Access: Actions ‚Üí This workflow run ‚Üí Artifacts section"
          Write-Output ""
          Write-Output "üìÅ Artifact Contents:"
          Write-Output "  ‚Ä¢ system-info.json - System and environment information"
          Write-Output "  ‚Ä¢ console-output-*.log - Complete console output from bot"
          Write-Output "  ‚Ä¢ error-output-*.log - Error stream output"
          Write-Output "  ‚Ä¢ structured-log-*.json - Parsed startup events and metrics"
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_launch.outputs.exit_code }}"
          $ExitReason = "${{ steps.bot_launch.outputs.exit_reason }}"
          
          if ($ExitReason -eq "timeout") {
            Write-Output "‚úÖ Status: SUCCESS (Completed scheduled runtime)"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot ran for the configured duration and was stopped gracefully."
            Write-Output "   This is expected behavior for diagnostic runs."
          } elseif ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot completed successfully."
          } else {
            Write-Output "‚ö†Ô∏è Status: COMPLETED WITH ISSUES"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot may have encountered errors. Check the artifacts for details."
          }
          
          Write-Output ""
          Write-Output "üí° Next Steps:"
          Write-Output "  1. Download the artifacts from this workflow run"
          Write-Output "  2. Review console-output-*.log for complete startup sequence"
          Write-Output "  3. Check structured-log-*.json for parsed events"
          Write-Output "  4. Analyze error-output-*.log if issues occurred"
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "‚úÖ DIAGNOSTICS COMPLETE"
          Write-Output "=================================================="
