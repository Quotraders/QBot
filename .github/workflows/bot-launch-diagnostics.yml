name: "ü§ñ Bot Launch Diagnostics - Self-Hosted"

on:
  workflow_dispatch:
    inputs:
      runtime_minutes:
        description: 'Bot runtime duration (minutes)'
        required: false
        default: '5'
        type: choice
        options:
          - '5'
          - '10'
          - '15'
          - '20'
          - '30'
      capture_detailed_logs:
        description: 'Capture detailed verbose logs'
        required: false
        default: true
        type: boolean

permissions:
  contents: read
  actions: write

env:
  TOPSTEPX_API_BASE: "https://api.topstepx.com"
  ARTIFACTS_DIR: "bot-diagnostics"

jobs:
  bot-launch-diagnostics:
    name: "Launch Bot with Full Diagnostics Capture"
    runs-on: self-hosted
    timeout-minutes: 40  # Covers max runtime (30min) + startup/shutdown buffer
    
    steps:
      - name: Configure Git
        run: |
          git config --global core.longpaths true
          git config --global core.symlinks false
      
      - name: "üì• Checkout Repository"
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      - name: "üîß Setup .NET SDK"
        uses: actions/setup-dotnet@v4
        env:
          DOTNET_INSTALL_DIR: ${{ runner.temp }}/.dotnet
        with:
          dotnet-version: '8.0.x'

      - name: "üîç Pre-Launch Environment Validation"
        id: env_validation
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç PRE-LAUNCH ENVIRONMENT VALIDATION"
          Write-Output "=================================================="
          Write-Output ""
          
          # Create diagnostics directory
          $DiagDir = "$env:RUNNER_TEMP\${{ env.ARTIFACTS_DIR }}"
          New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
          Write-Output "üìÅ Diagnostics directory: $DiagDir"
          Write-Output ""
          
          # System Information
          Write-Output "üñ•Ô∏è System Information:"
          Write-Output "  Runner: ${{ runner.name }}"
          Write-Output "  OS: ${{ runner.os }}"
          Write-Output "  Architecture: ${{ runner.arch }}"
          Write-Output "  Hostname: $env:COMPUTERNAME"
          Write-Output "  User: $env:USERNAME"
          Write-Output "  Working Directory: $(Get-Location)"
          Write-Output "  Temp Directory: $DiagDir"
          Write-Output ""
          
          # .NET Environment
          Write-Output "‚öôÔ∏è .NET Environment:"
          try {
            $DotnetVersion = dotnet --version
            Write-Output "  ‚úÖ .NET SDK: $DotnetVersion"
            Write-Output ""
            Write-Output "üìã .NET SDK Information:"
            dotnet --info
          } catch {
            Write-Output "  ‚ùå .NET SDK: Not found"
            Write-Output "  Error: $($_.Exception.Message)"
            exit 1
          }
          Write-Output ""
          
          # Check for .env file and load environment variables
          Write-Output "üìÑ Configuration Files:"
          if (Test-Path ".env") {
            Write-Output "  ‚úÖ .env file: Present"
            Write-Output "  üì• Loading environment variables from .env..."
            
            # Load .env file (same logic as run-bot-wsl.ps1)
            Get-Content ".env" | Where-Object { $_ -match '^[A-Z]' -and $_ -notmatch '^#' } | ForEach-Object {
              if ($_ -match '^([A-Z_]+)=(.*)$') {
                $key = $matches[1]
                $value = $matches[2]
                Set-Item -Path "env:$key" -Value $value
              }
            }
            Write-Output "  ‚úÖ Environment variables loaded from .env"
            Write-Output ""
            
            # Check for required environment variables (without exposing values)
            $RequiredVars = @(
              "TOPSTEPX_API_KEY",
              "TOPSTEPX_USERNAME", 
              "TOPSTEPX_ACCOUNT_ID",
              "DRY_RUN"
            )
            
            Write-Output "  üìã Environment Variables:"
            foreach ($VarName in $RequiredVars) {
              $VarValue = [Environment]::GetEnvironmentVariable($VarName)
              if ($VarValue) {
                Write-Output "    ‚úÖ ${VarName}: [SET]"
              } else {
                Write-Output "    ‚ùå ${VarName}: [MISSING]"
              }
            }
          } else {
            Write-Output "  ‚ùå .env file: Missing"
          }
          Write-Output ""
          
          # Save system info to JSON
          $SystemInfo = @{
            timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            runner = @{
              name = "${{ runner.name }}"
              os = "${{ runner.os }}"
              arch = "${{ runner.arch }}"
              hostname = $env:COMPUTERNAME
              user = $env:USERNAME
            }
            dotnet = @{
              version = $(try { dotnet --version } catch { "not found" })
            }
            workflow = @{
              name = "${{ github.workflow }}"
              run_id = "${{ github.run_id }}"
              run_number = "${{ github.run_number }}"
              triggered_by = "${{ github.actor }}"
            }
          }
          
          $SystemInfoFile = "$DiagDir\system-info.json"
          $SystemInfo | ConvertTo-Json -Depth 10 | Out-File -FilePath $SystemInfoFile -Encoding utf8
          Write-Output "üíæ System info saved to: system-info.json"
          Write-Output ""
          Write-Output "=================================================="
          
          # Export diagnostics directory for later steps
          "diag_dir=$DiagDir" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8

      - name: "üîß Setup .NET and Restore Packages"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîß .NET SETUP AND PACKAGE RESTORE"
          Write-Output "=================================================="
          Write-Output ""
          
          Write-Output "üì¶ Restoring NuGet packages..."
          $RestoreStart = Get-Date
          
          dotnet restore TopstepX.Bot.sln --verbosity minimal
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå NuGet restore failed"
            exit 1
          }
          
          $RestoreEnd = Get-Date
          $RestoreDuration = ($RestoreEnd - $RestoreStart).TotalSeconds
          
          Write-Output "‚úÖ NuGet restore completed in $($RestoreDuration.ToString('F2'))s"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üèóÔ∏è Build Trading Bot"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üèóÔ∏è BUILDING TRADING BOT"
          Write-Output "=================================================="
          Write-Output ""
          
          $BuildStart = Get-Date
          
          # Build UnifiedOrchestrator
          Write-Output "üî® Building UnifiedOrchestrator..."
          dotnet build src/UnifiedOrchestrator/UnifiedOrchestrator.csproj -c Release --no-restore
          
          if ($LASTEXITCODE -ne 0) {
            Write-Output "‚ùå Build failed"
            exit 1
          }
          
          $BuildEnd = Get-Date
          $BuildDuration = ($BuildEnd - $BuildStart).TotalSeconds
          
          Write-Output ""
          Write-Output "‚úÖ Build completed successfully in $($BuildDuration.ToString('F2'))s"
          Write-Output ""
          Write-Output "=================================================="

      - name: "üîç Verify Build Artifacts"
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üîç VERIFYING BUILD ARTIFACTS"
          Write-Output "=================================================="
          Write-Output ""
          
          $DllPath = "src/UnifiedOrchestrator/bin/Release/net8.0/UnifiedOrchestrator.dll"
          
          if (Test-Path $DllPath) {
            $FileSize = (Get-Item $DllPath).Length
            $FileSizeMB = [math]::Round($FileSize / 1MB, 2)
            Write-Output "‚úÖ UnifiedOrchestrator.dll found"
            Write-Output "   Size: $FileSizeMB MB"
            Write-Output "   Path: $DllPath"
          } else {
            Write-Output "‚ùå UnifiedOrchestrator.dll NOT FOUND"
            Write-Output "   Expected path: $DllPath"
            Write-Output ""
            Write-Output "üìÅ Listing build output directory:"
            Get-ChildItem "src/UnifiedOrchestrator/bin/Release/net8.0" -ErrorAction SilentlyContinue | Format-Table Name, Length
            exit 1
          }
          
          Write-Output ""
          Write-Output "=================================================="

      - name: "üöÄ Launch Bot with Full Diagnostics"
        id: bot_launch
        shell: pwsh
        continue-on-error: true
        run: |
          Write-Output "=================================================="
          Write-Output "üöÄ LAUNCHING TRADING BOT WITH DIAGNOSTICS"
          Write-Output "=================================================="
          Write-Output ""
          
          # Load .env file to ensure environment variables are available
          if (Test-Path ".env") {
            Write-Output "üì• Loading environment variables from .env..."
            Get-Content ".env" | Where-Object { $_ -match '^[A-Z]' -and $_ -notmatch '^#' } | ForEach-Object {
              if ($_ -match '^([A-Z_]+)=(.*)$') {
                $key = $matches[1]
                $value = $matches[2]
                Set-Item -Path "env:$key" -Value $value
              }
            }
            Write-Output "‚úÖ Environment variables loaded"
            Write-Output ""
          }
          
          $DiagDir = "${{ steps.env_validation.outputs.diag_dir }}"
          if ([string]::IsNullOrWhiteSpace($DiagDir)) {
            $DiagDir = "$env:RUNNER_TEMP\${{ env.ARTIFACTS_DIR }}"
            New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
            Write-Output "‚ö†Ô∏è Using fallback diagnostics directory: $DiagDir"
          }
          $Timestamp = (Get-Date).ToString("yyyy-MM-dd_HH-mm-ss")
          
          # Create log files
          $ConsoleLogFile = "$DiagDir\console-output-$Timestamp.log"
          $ErrorLogFile = "$DiagDir\error-output-$Timestamp.log"
          $StructuredLogFile = "$DiagDir\structured-log-$Timestamp.json"
          
          Write-Output "üìù Log files:"
          Write-Output "  Console: console-output-$Timestamp.log"
          Write-Output "  Errors: error-output-$Timestamp.log"
          Write-Output "  Structured: structured-log-$Timestamp.json"
          Write-Output ""
          
          # Override with DRY_RUN for safety (after loading .env)
          $env:DRY_RUN = "true"
          $env:ENABLE_DRY_RUN = "true"
          Write-Output "‚ö†Ô∏è DRY_RUN mode: ENABLED (safety mode - overrides .env)"
          Write-Output ""
          
          # Find dotnet executable
          $DotnetPath = (Get-Command dotnet -ErrorAction SilentlyContinue).Source
          if (-not $DotnetPath) {
            Write-Output "‚ùå ERROR: dotnet command not found in PATH"
            Write-Output "PATH: $env:PATH"
            exit 1
          }
          Write-Output "‚úÖ Using dotnet: $DotnetPath"
          Write-Output ""
          
          # Prepare bot launch
          Write-Output "üéØ Bot configuration:"
          Write-Output "  Runtime: ${{ github.event.inputs.runtime_minutes || '5' }} minutes"
          Write-Output "  Detailed logging: ${{ github.event.inputs.capture_detailed_logs || 'true' }}"
          Write-Output ""
          Write-Output "=================================================="
          Write-Output ""
          Write-Output "ü§ñ STARTING BOT..."
          Write-Output ""
          
          # Capture startup timestamp
          $StartTime = Get-Date
          $StartupLog = @{
            launch_timestamp = $StartTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            runtime_minutes = "${{ github.event.inputs.runtime_minutes || '5' }}"
            dry_run_enabled = $true
            workflow_run_id = "${{ github.run_id }}"
            events = @()
          }
          
          try {
            # Launch bot with output capture
            $ProcessInfo = New-Object System.Diagnostics.ProcessStartInfo
            $ProcessInfo.FileName = $DotnetPath
            $ProcessInfo.Arguments = "run --project src/UnifiedOrchestrator/UnifiedOrchestrator.csproj --no-build -c Release"
            $ProcessInfo.RedirectStandardOutput = $true
            $ProcessInfo.RedirectStandardError = $true
            $ProcessInfo.UseShellExecute = $false
            $ProcessInfo.CreateNoWindow = $true
            $ProcessInfo.WorkingDirectory = (Get-Location)
            
            # Copy environment variables to the new process
            foreach ($envVar in [Environment]::GetEnvironmentVariables().GetEnumerator()) {
              $ProcessInfo.Environment[$envVar.Name] = $envVar.Value
            }
            
            $Process = New-Object System.Diagnostics.Process
            $Process.StartInfo = $ProcessInfo
            
            # Output capture
            $OutputBuilder = New-Object System.Text.StringBuilder
            $ErrorBuilder = New-Object System.Text.StringBuilder
            $EventsList = New-Object System.Collections.ArrayList
            
            $OutputHandler = {
              if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
                $null = $OutputBuilder.AppendLine($EventArgs.Data)
                Write-Output $EventArgs.Data
                
                # Capture key startup events
                if ($EventArgs.Data -match '(\[STARTUP\]|\[CRITICAL\]|‚úÖ|‚ùå|üöÄ|‚ö†Ô∏è)') {
                  $EventEntry = @{
                    timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
                    type = "stdout"
                    message = $EventArgs.Data
                  }
                  $null = $EventsList.Add($EventEntry)
                }
              }
            }
            
            $ErrorHandler = {
              if (-not [string]::IsNullOrEmpty($EventArgs.Data)) {
                $null = $ErrorBuilder.AppendLine($EventArgs.Data)
                Write-Output "STDERR: $($EventArgs.Data)"
                
                $EventEntry = @{
                  timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ss.fffZ")
                  type = "stderr"
                  message = $EventArgs.Data
                }
                $null = $EventsList.Add($EventEntry)
              }
            }
            
            # Register event handlers
            $StdoutEvent = Register-ObjectEvent -InputObject $Process -EventName OutputDataReceived -Action $OutputHandler
            $StderrEvent = Register-ObjectEvent -InputObject $Process -EventName ErrorDataReceived -Action $ErrorHandler
            
            # Start process
            Write-Output "üîÑ Starting process..."
            $Started = $Process.Start()
            if (-not $Started) {
              Write-Output "‚ùå Failed to start process"
              exit 1
            }
            
            $Process.BeginOutputReadLine()
            $Process.BeginErrorReadLine()
            Write-Output "‚úÖ Process started (PID: $($Process.Id))"
            
            # Give process a few seconds to initialize
            Write-Output "‚è≥ Waiting for initialization..."
            Start-Sleep -Seconds 5
            
            # Check if process crashed immediately
            if ($Process.HasExited) {
              $ExitCode = $Process.ExitCode
              Write-Output ""
              Write-Output "‚ùå Process exited immediately with code: $ExitCode"
              Write-Output ""
              Write-Output "This usually indicates a startup failure. Check the logs for errors."
              
              # Cleanup
              $OutputBuilder.ToString() | Out-File -FilePath $ConsoleLogFile -Encoding utf8
              $ErrorBuilder.ToString() | Out-File -FilePath $ErrorLogFile -Encoding utf8
              
              Unregister-Event -SourceIdentifier $StdoutEvent.Name -ErrorAction SilentlyContinue
              Unregister-Event -SourceIdentifier $StderrEvent.Name -ErrorAction SilentlyContinue
              Remove-Job -Name $StdoutEvent.Name -Force -ErrorAction SilentlyContinue
              Remove-Job -Name $StderrEvent.Name -Force -ErrorAction SilentlyContinue
              
              # Show first 100 lines of output for debugging
              Write-Output "üìã First 100 lines of output:"
              Write-Output "=================================================="
              Get-Content $ConsoleLogFile -Head 100 -ErrorAction SilentlyContinue
              Write-Output "=================================================="
              
              # Also show errors
              if (Test-Path $ErrorLogFile) {
                Write-Output ""
                Write-Output "üìã Error output:"
                Write-Output "=================================================="
                Get-Content $ErrorLogFile -ErrorAction SilentlyContinue
                Write-Output "=================================================="
              }
              
              exit 1
            }
            
            Write-Output ""
            Write-Output "‚è±Ô∏è Bot is running... (will run for ${{ github.event.inputs.runtime_minutes || '5' }} minutes)"
            Write-Output ""
            
            # Wait for specified duration with periodic checks
            $RuntimeMinutes = [int]"${{ github.event.inputs.runtime_minutes || '5' }}"
            $TimeoutSeconds = $RuntimeMinutes * 60
            $CheckIntervalSeconds = 10
            $ElapsedSeconds = 0
            
            while ($ElapsedSeconds -lt $TimeoutSeconds -and -not $Process.HasExited) {
              Start-Sleep -Seconds $CheckIntervalSeconds
              $ElapsedSeconds += $CheckIntervalSeconds
              
              # Show progress every 30 seconds
              if ($ElapsedSeconds % 30 -eq 0) {
                $RemainingMinutes = [math]::Round(($TimeoutSeconds - $ElapsedSeconds) / 60, 1)
                Write-Output "‚è±Ô∏è Still running... ($RemainingMinutes minutes remaining)"
              }
            }
            
            $EndTime = Get-Date
            $ActualRuntime = ($EndTime - $StartTime).TotalSeconds
            
            # Cleanup event handlers
            Write-Output "üßπ Cleaning up event handlers..."
            Unregister-Event -SourceIdentifier $StdoutEvent.Name -ErrorAction SilentlyContinue
            Unregister-Event -SourceIdentifier $StderrEvent.Name -ErrorAction SilentlyContinue
            Remove-Job -Name $StdoutEvent.Name -Force -ErrorAction SilentlyContinue
            Remove-Job -Name $StderrEvent.Name -Force -ErrorAction SilentlyContinue
            
            # Stop process if still running
            if (-not $Process.HasExited) {
              Write-Output ""
              Write-Output "‚è±Ô∏è Runtime limit reached ($RuntimeMinutes minutes)"
              Write-Output "üõë Stopping bot gracefully..."
              
              # Try graceful shutdown first
              try {
                $Process.CloseMainWindow() | Out-Null
                Start-Sleep -Seconds 5
              } catch {
                Write-Output "‚ö†Ô∏è Could not close main window gracefully"
              }
              
              # Force kill if still running
              if (-not $Process.HasExited) {
                Write-Output "üî® Force stopping process..."
                $Process.Kill($true)  # Kill entire process tree
                Start-Sleep -Seconds 2
              }
              
              $ExitCode = 0  # Timeout is expected, not an error
              $ExitReason = "timeout"
            } else {
              $ExitCode = $Process.ExitCode
              $ExitReason = "exited"
              Write-Output "‚úÖ Bot exited naturally with code: $ExitCode"
            }
            
            # Save all outputs
            $OutputBuilder.ToString() | Out-File -FilePath $ConsoleLogFile -Encoding utf8
            $ErrorBuilder.ToString() | Out-File -FilePath $ErrorLogFile -Encoding utf8
            
            # Complete structured log
            $StartupLog.end_timestamp = $EndTime.ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
            $StartupLog.actual_runtime_seconds = [math]::Round($ActualRuntime, 2)
            $StartupLog.exit_code = $ExitCode
            $StartupLog.exit_reason = $ExitReason
            $StartupLog.events = $EventsList.ToArray()
            
            $StartupLog | ConvertTo-Json -Depth 10 | Out-File -FilePath $StructuredLogFile -Encoding utf8
            
            Write-Output ""
            Write-Output "=================================================="
            Write-Output "üìä BOT EXECUTION SUMMARY"
            Write-Output "=================================================="
            Write-Output "  Exit Code: $ExitCode"
            Write-Output "  Exit Reason: $ExitReason"
            Write-Output "  Actual Runtime: $($ActualRuntime.ToString('F2'))s"
            Write-Output "  Events Captured: $($EventsList.Count)"
            Write-Output "=================================================="
            Write-Output ""
            
            # Output last 150 lines for GitHub Actions UI
            Write-Output "üìã LAST 150 LINES OF OUTPUT:"
            Write-Output "=================================================="
            Get-Content $ConsoleLogFile -Tail 150 -ErrorAction SilentlyContinue
            Write-Output "=================================================="
            
            # Set outputs
            "exit_code=$ExitCode" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "exit_reason=$ExitReason" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "runtime_seconds=$([math]::Round($ActualRuntime, 2))" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            "events_captured=$($EventsList.Count)" | Out-File -FilePath $env:GITHUB_OUTPUT -Append -Encoding utf8
            
          } catch {
            Write-Output ""
            Write-Output "‚ùå CRITICAL ERROR DURING BOT EXECUTION"
            Write-Output "=================================================="
            Write-Output "Error: $($_.Exception.Message)"
            Write-Output "Stack Trace:"
            Write-Output $_.Exception.StackTrace
            Write-Output "=================================================="
            
            # Save error to logs
            $ErrorInfo = @{
              error_timestamp = (Get-Date).ToUniversalTime().ToString("yyyy-MM-ddTHH:mm:ssZ")
              error_message = $_.Exception.Message
              stack_trace = $_.Exception.StackTrace
            }
            
            "CRITICAL ERROR: $($_.Exception.Message)" | Out-File -FilePath $ErrorLogFile -Append -Encoding utf8
            $_.Exception.StackTrace | Out-File -FilePath $ErrorLogFile -Append -Encoding utf8
            $ErrorInfo | ConvertTo-Json -Depth 10 | Out-File -FilePath "$DiagDir\critical-error-$Timestamp.json" -Encoding utf8
            
            exit 1
          }

      - name: "üì¶ Package Diagnostics Artifacts"
        if: always()
        shell: pwsh
        run: |
          Write-Output "=================================================="
          Write-Output "üì¶ PACKAGING DIAGNOSTICS ARTIFACTS"
          Write-Output "=================================================="
          Write-Output ""
          
          $DiagDir = "${{ steps.env_validation.outputs.diag_dir }}"
          if ([string]::IsNullOrWhiteSpace($DiagDir)) {
            $DiagDir = "$env:RUNNER_TEMP\${{ env.ARTIFACTS_DIR }}"
            Write-Output "‚ö†Ô∏è Using fallback diagnostics directory: $DiagDir"
          }
          
          # Check if directory exists and has content
          if (-not (Test-Path $DiagDir)) {
            Write-Output "‚ö†Ô∏è Diagnostics directory not found: $DiagDir"
            Write-Output "   This may indicate the workflow failed early."
            New-Item -ItemType Directory -Path $DiagDir -Force | Out-Null
            "Workflow failed during early stage - no diagnostics captured" | Out-File -FilePath "$DiagDir\workflow-failure-note.txt" -Encoding utf8
            return
          }
          
          # List all captured files
          Write-Output "üìÅ Captured artifacts:"
          Get-ChildItem -Path $DiagDir | ForEach-Object {
            $SizeKB = [math]::Round($_.Length / 1KB, 2)
            Write-Output "  üìÑ $($_.Name) ($SizeKB KB)"
          }
          
          Write-Output ""
          Write-Output "‚úÖ Diagnostics packaged and ready for upload"
          Write-Output ""
          Write-Output "=================================================="

      - name: "‚¨ÜÔ∏è Upload Diagnostics Artifacts"
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: bot-diagnostics-run-${{ github.run_number }}
          path: ${{ steps.env_validation.outputs.diag_dir || format('{0}/{1}', runner.temp, env.ARTIFACTS_DIR) }}
          retention-days: 30
          compression-level: 6

      - name: "üìä Final Execution Report"
        if: always()
        shell: pwsh
        run: |
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "üìä BOT LAUNCH DIAGNOSTICS - FINAL REPORT"
          Write-Output "=================================================="
          Write-Output ""
          Write-Output "ü§ñ Bot Launch Summary:"
          Write-Output "  Workflow: ${{ github.workflow }}"
          Write-Output "  Run ID: ${{ github.run_id }}"
          Write-Output "  Run Number: ${{ github.run_number }}"
          Write-Output "  Triggered By: ${{ github.actor }}"
          Write-Output ""
          Write-Output "üìä Execution Results:"
          Write-Output "  Exit Code: ${{ steps.bot_launch.outputs.exit_code || 'N/A' }}"
          Write-Output "  Exit Reason: ${{ steps.bot_launch.outputs.exit_reason || 'N/A' }}"
          Write-Output "  Runtime: ${{ steps.bot_launch.outputs.runtime_seconds || 'N/A' }}s"
          Write-Output "  Events Captured: ${{ steps.bot_launch.outputs.events_captured || 'N/A' }}"
          Write-Output ""
          Write-Output "üì¶ Artifacts:"
          Write-Output "  Name: bot-diagnostics-run-${{ github.run_number }}"
          Write-Output "  Location: GitHub Actions Artifacts (30 day retention)"
          Write-Output "  Access: Actions ‚Üí This workflow run ‚Üí Artifacts section"
          Write-Output ""
          Write-Output "üìÅ Artifact Contents:"
          Write-Output "  ‚Ä¢ system-info.json - System and environment information"
          Write-Output "  ‚Ä¢ console-output-*.log - Complete console output from bot"
          Write-Output "  ‚Ä¢ error-output-*.log - Error stream output"
          Write-Output "  ‚Ä¢ structured-log-*.json - Parsed startup events and metrics"
          Write-Output ""
          
          $ExitCode = "${{ steps.bot_launch.outputs.exit_code }}"
          $ExitReason = "${{ steps.bot_launch.outputs.exit_reason }}"
          
          if ($ExitReason -eq "timeout") {
            Write-Output "‚úÖ Status: SUCCESS (Completed scheduled runtime)"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot ran for the configured duration and was stopped gracefully."
            Write-Output "   This is expected behavior for diagnostic runs."
          } elseif ($ExitCode -eq "0") {
            Write-Output "‚úÖ Status: SUCCESS"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot completed successfully."
          } else {
            Write-Output "‚ö†Ô∏è Status: COMPLETED WITH ISSUES"
            Write-Output ""
            Write-Output "‚ÑπÔ∏è The bot may have encountered errors. Check the artifacts for details."
          }
          
          Write-Output ""
          Write-Output "üí° Next Steps:"
          Write-Output "  1. Download the artifacts from this workflow run"
          Write-Output "  2. Review console-output-*.log for complete startup sequence"
          Write-Output "  3. Check structured-log-*.json for parsed events"
          Write-Output "  4. Analyze error-output-*.log if issues occurred"
          Write-Output ""
          Write-Output "=================================================="
          Write-Output "‚úÖ DIAGNOSTICS COMPLETE"
          Write-Output "=================================================="
