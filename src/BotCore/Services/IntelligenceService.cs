using System.Text.Json;
using Microsoft.Extensions.Logging;

// Use explicit alias to resolve MarketContext ambiguity - we want the Intelligence one
using IntelligenceMarketContext = BotCore.Models.MarketContext;

namespace BotCore.Services;

/// <summary>
/// Interface for intelligence service
/// </summary>
public interface IIntelligenceService
{
    Task<IntelligenceMarketContext?> GetLatestIntelligenceAsync();
    bool IsIntelligenceAvailable();
    TimeSpan? GetIntelligenceAge();
    Task LogTradeResultAsync(string symbol, decimal entryPrice, decimal exitPrice, decimal pnl, IntelligenceMarketContext? intelligenceUsed = null);

    // New methods for position sizing and risk management
    bool ShouldTrade(IntelligenceMarketContext? intelligence = null);
    decimal GetPositionSizeMultiplier(IntelligenceMarketContext? intelligence = null);
    decimal GetStopLossMultiplier(IntelligenceMarketContext? intelligence = null);
    decimal GetTakeProfitMultiplier(IntelligenceMarketContext? intelligence = null);
    string GetPreferredStrategy(IntelligenceMarketContext? intelligence = null);
    bool IsHighVolatilityEvent(IntelligenceMarketContext? intelligence = null);
}

/// <summary>
/// Service for consuming intelligence data generated by the Intelligence pipeline.
/// Provides graceful degradation when intelligence is unavailable.
/// </summary>
public class IntelligenceService : IIntelligenceService
{
    private readonly string _signalsPath;
    private readonly ILogger<IntelligenceService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public IntelligenceService(ILogger<IntelligenceService> logger, string? signalsPath = null)
    {
        _logger = logger;
        _signalsPath = signalsPath ?? "data/signals/latest.json";
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };
    }

    /// <summary>
    /// Gets the latest market intelligence. Returns null if intelligence is unavailable.
    /// The bot should continue normally when this returns null.
    /// </summary>
    /// <returns>Market context if available, null otherwise</returns>
    public async Task<IntelligenceMarketContext?> GetLatestIntelligenceAsync()
    {
        try
        {
            if (!File.Exists(_signalsPath))
            {
                _logger.LogDebug("[INTEL] Signals file not found: {Path}", _signalsPath);
                return null;
            }

            var json = await File.ReadAllTextAsync(_signalsPath);
            if (string.IsNullOrWhiteSpace(json))
            {
                _logger.LogDebug("[INTEL] Signals file is empty");
                return null;
            }

            var marketContext = JsonSerializer.Deserialize<IntelligenceMarketContext>(json, _jsonOptions);
            if (marketContext != null)
            {
                _logger.LogInformation("[INTEL] Successfully loaded intelligence: Regime={Regime}, Confidence={Confidence:F2}, Bias={Bias}",
                    marketContext.Regime, marketContext.ModelConfidence, marketContext.PrimaryBias);
            }

            return marketContext;
        }
        catch (JsonException ex)
        {
            _logger.LogWarning("[INTEL] Failed to parse signals file: {Error}", ex.Message);
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogDebug("[INTEL] Intelligence unavailable: {Error}", ex.Message);
            return null;
        }
    }

    /// <summary>
    /// Checks if intelligence is currently available
    /// </summary>
    public bool IsIntelligenceAvailable()
    {
        return File.Exists(_signalsPath);
    }

    /// <summary>
    /// Gets the age of the latest intelligence data in minutes
    /// </summary>
    public TimeSpan? GetIntelligenceAge()
    {
        try
        {
            if (!File.Exists(_signalsPath))
                return null;

            var fileInfo = new FileInfo(_signalsPath);
            return DateTime.UtcNow - fileInfo.LastWriteTimeUtc;
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Logs a trade result for the Intelligence feedback loop
    /// </summary>
    public async Task LogTradeResultAsync(string symbol, decimal entryPrice, decimal exitPrice,
        decimal pnl, IntelligenceMarketContext? intelligenceUsed = null)
    {
        try
        {
            var resultsFolderPath = Path.GetDirectoryName(_signalsPath)?.Replace("signals", "trades")
                                   ?? "data/trades/";

            Directory.CreateDirectory(resultsFolderPath);

            var resultsPath = Path.Combine(resultsFolderPath, "results.jsonl");

            var tradeResult = new
            {
                Timestamp = DateTime.UtcNow,
                Symbol = symbol,
                Entry = entryPrice,
                Exit = exitPrice,
                PnL = pnl,
                IntelligenceUsed = intelligenceUsed != null,
                IntelligenceConfidence = intelligenceUsed?.ModelConfidence ?? 0,
                IntelligenceRegime = intelligenceUsed?.Regime ?? "Unknown",
                IntelligenceBias = intelligenceUsed?.PrimaryBias ?? "Unknown"
            };

            var json = JsonSerializer.Serialize(tradeResult, _jsonOptions);
            await File.AppendAllTextAsync(resultsPath, json + Environment.NewLine);

            _logger.LogDebug("[INTEL] Logged trade result: {Symbol} PnL={PnL:F2} with intelligence={HasIntel}",
                symbol, pnl, intelligenceUsed != null);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("[INTEL] Failed to log trade result: {Error}", ex.Message);
        }
    }

    /// <summary>
    /// Determines if trading should proceed based on intelligence data.
    /// Always returns true (aggressive trading philosophy).
    /// </summary>
    public bool ShouldTrade(IntelligenceMarketContext? intelligence = null)
    {
        // Aggressive trading philosophy: always trade, just adjust size and risk
        return true;
    }

    /// <summary>
    /// Gets position size multiplier based on market conditions
    /// </summary>
    public decimal GetPositionSizeMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return 1.0m; // Default size when no intelligence

        decimal multiplier = 1.0m;

        // Adjust based on confidence (single check)
        if (intelligence.ModelConfidence >= 0.8m)
            multiplier *= 1.5m; // High confidence
        else if (intelligence.ModelConfidence <= 0.4m)
            multiplier *= 0.6m; // Low confidence

        // Adjust based on volatility events (single check)
        if (intelligence.IsFomcDay || intelligence.IsCpiDay)
            multiplier *= 0.5m; // Reduce size on major events

        // Adjust based on news intensity
        if (intelligence.NewsIntensity >= 70m)
            multiplier *= 0.7m; // High news intensity = reduce size
        else if (intelligence.NewsIntensity <= 20m)
            multiplier *= 1.2m; // Low news intensity = increase size
        
        // Market regime adjustments
        if (intelligence.Regime == "Volatile")
            multiplier *= 0.75m; // Volatile markets = reduce size
        else if (intelligence.Regime == "Trending")
            multiplier *= 1.1m; // Trending markets = increase size
        
        // Bias strength consideration
        if (intelligence.PrimaryBias == "Neutral")
            multiplier *= 0.95m; // Neutral bias = slight decrease
        
        // Time-based adjustments (institutional activity patterns)
        var hour = DateTime.UtcNow.Hour;
        if (hour >= 9 && hour <= 11) // Morning institutional activity
            multiplier *= 1.05m;
        else if (hour >= 15 && hour <= 16) // Power hour
            multiplier *= 1.02m;

        // Clamp to reasonable bounds
        return Math.Max(0.2m, Math.Min(multiplier, 2.0m));
    }

    /// <summary>
    /// Gets stop loss multiplier for wider stops during volatile periods
    /// </summary>
    public decimal GetStopLossMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return 1.0m;

        decimal multiplier = 1.0m;

        // Wider stops on FOMC/CPI days
        if (intelligence.IsFomcDay)
            multiplier *= 2.0m;
        else if (intelligence.IsCpiDay)
            multiplier *= 1.5m;

        // Wider stops in volatile regimes
        if (intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase))
            multiplier *= 1.5m;

        // High news intensity requires wider stops
        if (intelligence.NewsIntensity >= 80m)
            multiplier *= 1.3m;

        return Math.Max(1.0m, Math.Min(multiplier, 3.0m));
    }

    /// <summary>
    /// Gets take profit multiplier for extended targets during favorable conditions
    /// </summary>
    public decimal GetTakeProfitMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return 1.0m;

        decimal multiplier = 1.0m;

        // Extended targets on FOMC days (capture full move)
        if (intelligence.IsFomcDay)
            multiplier *= 3.0m;
        else if (intelligence.IsCpiDay)
            multiplier *= 2.0m;

        // Extended targets in trending markets with high confidence
        if (intelligence.Regime.Equals("Trending", StringComparison.OrdinalIgnoreCase) &&
            intelligence.ModelConfidence >= 0.7m)
            multiplier *= 2.0m;

        // Volatile regimes get extended targets
        if (intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase))
            multiplier *= 1.5m;

        return Math.Max(1.0m, Math.Min(multiplier, 4.0m));
    }

    /// <summary>
    /// Selects preferred strategy based on market regime
    /// </summary>
    public string GetPreferredStrategy(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return "S2"; // Default to mean reversion

        return intelligence.Regime.ToUpperInvariant() switch
        {
            "VOLATILE" => "S11L", // Mean reversion for volatility
            "TRENDING" => "S3",   // Momentum for trends
            "RANGING" => "S2",    // Fade extremes in ranges
            _ => "S2"             // Default to mean reversion
        };
    }

    /// <summary>
    /// Detects high volatility events based on intelligence data
    /// </summary>
    public bool IsHighVolatilityEvent(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return false;

        return intelligence.IsFomcDay ||
               intelligence.IsCpiDay ||
               intelligence.NewsIntensity >= 80m ||
               intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase);
    }
}