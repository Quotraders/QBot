using System.Text.Json;
using Microsoft.Extensions.Logging;
using TradingBot.Abstractions;
using BotCore.Models; // For TradeSetup class
using TradingBot.BotCore.Services; // For MLConfigurationService

// Use the canonical MarketContext from Abstractions
using IntelligenceMarketContext = TradingBot.Abstractions.MarketContext;

namespace BotCore.Services;

/// <summary>
/// Constants for intelligence service trading adjustments
/// </summary>
public static class IntelligenceServiceConstants
{
    // Default multipliers
    public const decimal DefaultMultiplier = 1.0m;
    
    // Position sizing thresholds and multipliers
    public const decimal HighConfidenceThreshold = 0.8m;
    public const decimal LowConfidenceThreshold = 0.4m;
    public const decimal HighConfidenceMultiplier = 1.5m;
    public const decimal LowConfidenceMultiplier = 0.6m;
    public const decimal VolatilityEventMultiplier = 0.5m;
    public const decimal HighNewsIntensityThreshold = 70m;
    public const decimal LowNewsIntensityThreshold = 20m;
    public const decimal HighNewsMultiplier = 0.7m;
    public const decimal LowNewsMultiplier = 1.2m;
    public const decimal VolatileRegimeMultiplier = 0.75m;
    public const decimal TrendingRegimeMultiplier = 1.1m;
    public const decimal NeutralBiasMultiplier = 0.95m;
    
    // Time-based adjustment hours (UTC)
    public const int MorningInstitutionalStartHour = 9;
    public const int MorningInstitutionalEndHour = 11;
    public const decimal MorningInstitutionalMultiplier = 1.05m;
    public const int PowerHourStartHour = 15;
    public const int PowerHourEndHour = 16;
    public const decimal PowerHourMultiplier = 1.02m;
    
    // Position size bounds
    public const decimal MinPositionSizeMultiplier = 0.2m;
    public const decimal MaxPositionSizeMultiplier = 2.0m;
    
    // Stop loss multipliers
    public const decimal FomcDayStopMultiplier = 2.0m;
    public const decimal CpiDayStopMultiplier = 1.5m;
    public const decimal VolatileStopMultiplier = 1.5m;
    public const decimal HighNewsStopThreshold = 80m;
    public const decimal HighNewsStopMultiplier = 1.3m;
    public const decimal MinStopLossMultiplier = 1.0m;
    public const decimal MaxStopLossMultiplier = 3.0m;
    
    // Take profit multipliers
    public const decimal FomcDayTakeProfitMultiplier = 3.0m;
    public const decimal CpiDayTakeProfitMultiplier = 2.0m;
    public const decimal TrendingHighConfidenceTakeProfitMultiplier = 2.0m;
    public const decimal VolatileTakeProfitMultiplier = 1.5m;
    public const decimal MinTakeProfitMultiplier = 1.0m;
    public const decimal MaxTakeProfitMultiplier = 4.0m;
    
    // High volatility event detection threshold
    public const decimal HighVolatilityNewsIntensityThreshold = 80m;
}

/// <summary>
/// Interface for intelligence service
/// </summary>
public interface IIntelligenceService
{
    Task<IntelligenceMarketContext?> GetLatestIntelligenceAsync();
    bool IsIntelligenceAvailable();
    TimeSpan? GetIntelligenceAge();
    Task LogTradeResultAsync(string symbol, decimal entryPrice, decimal exitPrice, decimal pnl, IntelligenceMarketContext? intelligenceUsed = null);

    // New methods for position sizing and risk management
    bool ShouldTrade(IntelligenceMarketContext? intelligence = null);
    decimal GetPositionSizeMultiplier(IntelligenceMarketContext? intelligence = null);
    decimal GetStopLossMultiplier(IntelligenceMarketContext? intelligence = null);
    decimal GetTakeProfitMultiplier(IntelligenceMarketContext? intelligence = null);
    string GetPreferredStrategy(IntelligenceMarketContext? intelligence = null);
    bool IsHighVolatilityEvent(IntelligenceMarketContext? intelligence = null);
}

/// <summary>
/// Service for consuming intelligence data generated by the Intelligence pipeline.
/// Provides graceful degradation when intelligence is unavailable.
/// </summary>
public class IntelligenceService : IIntelligenceService
{
    private readonly string _signalsPath;
    private readonly ILogger<IntelligenceService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;
    private readonly MLConfigurationService _mlConfig;

    public IntelligenceService(ILogger<IntelligenceService> logger, MLConfigurationService mlConfig, string? signalsPath = null)
    {
        _logger = logger;
        _mlConfig = mlConfig;
        _signalsPath = signalsPath ?? "data/signals/latest.json";
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };
    }

    /// <summary>
    /// Gets the latest market intelligence. Returns null if intelligence is unavailable.
    /// The bot should continue normally when this returns null.
    /// </summary>
    /// <returns>Market context if available, null otherwise</returns>
    public async Task<IntelligenceMarketContext?> GetLatestIntelligenceAsync()
    {
        try
        {
            if (!File.Exists(_signalsPath))
            {
                _logger.LogDebug("[INTEL] Signals file not found: {Path}", _signalsPath);
                return null;
            }

            var json = await File.ReadAllTextAsync(_signalsPath).ConfigureAwait(false);
            if (string.IsNullOrWhiteSpace(json))
            {
                _logger.LogDebug("[INTEL] Signals file is empty");
                return null;
            }

            var marketContext = JsonSerializer.Deserialize<IntelligenceMarketContext>(json, _jsonOptions);
            if (marketContext != null)
            {
                _logger.LogInformation("[INTEL] Successfully loaded intelligence: Regime={Regime}, Confidence={Confidence:F2}, Bias={Bias}",
                    marketContext.Regime, marketContext.ModelConfidence, marketContext.PrimaryBias);
            }

            return marketContext;
        }
        catch (JsonException ex)
        {
            _logger.LogWarning("[INTEL] Failed to parse signals file: {Error}", ex.Message);
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogDebug("[INTEL] Intelligence unavailable: {Error}", ex.Message);
            return null;
        }
    }

    /// <summary>
    /// Checks if intelligence is currently available
    /// </summary>
    public bool IsIntelligenceAvailable()
    {
        return File.Exists(_signalsPath);
    }

    /// <summary>
    /// Gets the age of the latest intelligence data in minutes
    /// </summary>
    public TimeSpan? GetIntelligenceAge()
    {
        try
        {
            if (!File.Exists(_signalsPath))
                return null;

            var fileInfo = new FileInfo(_signalsPath);
            return DateTime.UtcNow - fileInfo.LastWriteTimeUtc;
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Logs a trade result for the Intelligence feedback loop
    /// </summary>
    public async Task LogTradeResultAsync(string symbol, decimal entryPrice, decimal exitPrice,
        decimal pnl, IntelligenceMarketContext? intelligenceUsed = null)
    {
        try
        {
            var resultsFolderPath = Path.GetDirectoryName(_signalsPath)?.Replace("signals", "trades")
                                   ?? "data/trades/";

            Directory.CreateDirectory(resultsFolderPath);

            var resultsPath = Path.Combine(resultsFolderPath, "results.jsonl");

            var tradeResult = new
            {
                Timestamp = DateTime.UtcNow,
                Symbol = symbol,
                Entry = entryPrice,
                Exit = exitPrice,
                PnL = pnl,
                IntelligenceUsed = intelligenceUsed != null,
                IntelligenceConfidence = intelligenceUsed?.ModelConfidence ?? 0,
                IntelligenceRegime = intelligenceUsed?.Regime ?? "Unknown",
                IntelligenceBias = intelligenceUsed?.PrimaryBias ?? "Unknown"
            };

            var json = JsonSerializer.Serialize(tradeResult, _jsonOptions);
            await File.AppendAllTextAsync(resultsPath, json + Environment.NewLine).ConfigureAwait(false);

            _logger.LogDebug("[INTEL] Logged trade result: {Symbol} PnL={PnL:F2} with intelligence={HasIntel}",
                symbol, pnl, intelligenceUsed != null);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("[INTEL] Failed to log trade result: {Error}", ex.Message);
        }
    }

    /// <summary>
    /// Determines if trading should proceed based on intelligence data.
    /// Always returns true (aggressive trading philosophy).
    /// </summary>
    public bool ShouldTrade(IntelligenceMarketContext? intelligence = null)
    {
        // Aggressive trading philosophy: always trade, just adjust size and risk
        return true;
    }

    /// <summary>
    /// Gets position size multiplier based on market conditions
    /// </summary>
    public decimal GetPositionSizeMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return IntelligenceServiceConstants.DefaultMultiplier; // Default size when no intelligence

        decimal multiplier = IntelligenceServiceConstants.DefaultMultiplier;

        // Adjust based on confidence (single check)
        if ((decimal)intelligence.ModelConfidence >= IntelligenceServiceConstants.HighConfidenceThreshold)
            multiplier *= IntelligenceServiceConstants.HighConfidenceMultiplier; // High confidence
        else if ((decimal)intelligence.ModelConfidence <= IntelligenceServiceConstants.LowConfidenceThreshold)
            multiplier *= IntelligenceServiceConstants.LowConfidenceMultiplier; // Low confidence

        // Adjust based on volatility events (single check)
        if (intelligence.IsFomcDay || intelligence.IsCpiDay)
            multiplier *= IntelligenceServiceConstants.VolatilityEventMultiplier; // Reduce size on major events

        // Adjust based on news intensity
        if ((decimal)intelligence.NewsIntensity >= IntelligenceServiceConstants.HighNewsIntensityThreshold)
            multiplier *= IntelligenceServiceConstants.HighNewsMultiplier; // High news intensity = reduce size
        else if ((decimal)intelligence.NewsIntensity <= IntelligenceServiceConstants.LowNewsIntensityThreshold)
            multiplier *= IntelligenceServiceConstants.LowNewsMultiplier; // Low news intensity = increase size
        
        // Market regime adjustments
        if (intelligence.Regime == "Volatile")
            multiplier *= IntelligenceServiceConstants.VolatileRegimeMultiplier; // Volatile markets = reduce size
        else if (intelligence.Regime == "Trending")
            multiplier *= IntelligenceServiceConstants.TrendingRegimeMultiplier; // Trending markets = increase size
        
        // Bias strength consideration
        if (intelligence.PrimaryBias == "Neutral")
            multiplier *= IntelligenceServiceConstants.NeutralBiasMultiplier; // Neutral bias = slight decrease
        
        // Time-based adjustments (institutional activity patterns)
        var hour = DateTime.UtcNow.Hour;
        if (hour >= IntelligenceServiceConstants.MorningInstitutionalStartHour && hour <= IntelligenceServiceConstants.MorningInstitutionalEndHour) // Morning institutional activity
            multiplier *= IntelligenceServiceConstants.MorningInstitutionalMultiplier;
        else if (hour >= IntelligenceServiceConstants.PowerHourStartHour && hour <= IntelligenceServiceConstants.PowerHourEndHour) // Power hour
            multiplier *= IntelligenceServiceConstants.PowerHourMultiplier;

        // Clamp to reasonable bounds
        return Math.Max(IntelligenceServiceConstants.MinPositionSizeMultiplier, Math.Min(multiplier, IntelligenceServiceConstants.MaxPositionSizeMultiplier));
    }

    /// <summary>
    /// Gets stop loss multiplier for wider stops during volatile periods
    /// </summary>
    public decimal GetStopLossMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return IntelligenceServiceConstants.DefaultMultiplier;

        decimal multiplier = IntelligenceServiceConstants.DefaultMultiplier;

        // Wider stops on FOMC/CPI days
        if (intelligence.IsFomcDay)
            multiplier *= IntelligenceServiceConstants.FomcDayStopMultiplier;
        else if (intelligence.IsCpiDay)
            multiplier *= IntelligenceServiceConstants.CpiDayStopMultiplier;

        // Wider stops in volatile regimes
        if (intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase))
            multiplier *= IntelligenceServiceConstants.VolatileStopMultiplier;

        // High news intensity requires wider stops
        if ((decimal)intelligence.NewsIntensity >= IntelligenceServiceConstants.HighNewsStopThreshold)
            multiplier *= IntelligenceServiceConstants.HighNewsStopMultiplier;

        return Math.Max(IntelligenceServiceConstants.MinStopLossMultiplier, Math.Min(multiplier, IntelligenceServiceConstants.MaxStopLossMultiplier));
    }

    /// <summary>
    /// Gets take profit multiplier for extended targets during favorable conditions
    /// </summary>
    public decimal GetTakeProfitMultiplier(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return IntelligenceServiceConstants.DefaultMultiplier;

        decimal multiplier = IntelligenceServiceConstants.DefaultMultiplier;

        // Extended targets on FOMC days (capture full move)
        if (intelligence.IsFomcDay)
            multiplier *= IntelligenceServiceConstants.FomcDayTakeProfitMultiplier;
        else if (intelligence.IsCpiDay)
            multiplier *= IntelligenceServiceConstants.CpiDayTakeProfitMultiplier;

        // Extended targets in trending markets with high confidence
        if (intelligence.Regime.Equals("Trending", StringComparison.OrdinalIgnoreCase) &&
            (decimal)intelligence.ModelConfidence >= (decimal)_mlConfig.GetAIConfidenceThreshold())
            multiplier *= IntelligenceServiceConstants.TrendingHighConfidenceTakeProfitMultiplier;

        // Volatile regimes get extended targets
        if (intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase))
            multiplier *= IntelligenceServiceConstants.VolatileTakeProfitMultiplier;

        return Math.Max(IntelligenceServiceConstants.MinTakeProfitMultiplier, Math.Min(multiplier, IntelligenceServiceConstants.MaxTakeProfitMultiplier));
    }

    /// <summary>
    /// Selects preferred strategy based on market regime
    /// </summary>
    public string GetPreferredStrategy(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return "S2"; // Default to mean reversion

        return intelligence.Regime.ToUpperInvariant() switch
        {
            "VOLATILE" => "S11L", // Mean reversion for volatility
            "TRENDING" => "S3",   // Momentum for trends
            "RANGING" => "S2",    // Fade extremes in ranges
            _ => "S2"             // Default to mean reversion
        };
    }

    /// <summary>
    /// Detects high volatility events based on intelligence data
    /// </summary>
    public bool IsHighVolatilityEvent(IntelligenceMarketContext? intelligence = null)
    {
        if (intelligence == null)
            return false;

        return intelligence.IsFomcDay ||
               intelligence.IsCpiDay ||
               (decimal)intelligence.NewsIntensity >= IntelligenceServiceConstants.HighVolatilityNewsIntensityThreshold ||
               intelligence.Regime.Equals("Volatile", StringComparison.OrdinalIgnoreCase);
    }
}