using System.Text.Json;
using BotCore.Models;
using Microsoft.Extensions.Logging;

namespace BotCore.Services;

/// <summary>
/// Service for consuming intelligence data generated by the Intelligence pipeline.
/// Provides graceful degradation when intelligence is unavailable.
/// </summary>
public class IntelligenceService
{
    private readonly string _signalsPath;
    private readonly ILogger<IntelligenceService> _logger;
    private readonly JsonSerializerOptions _jsonOptions;

    public IntelligenceService(ILogger<IntelligenceService> logger, string? signalsPath = null)
    {
        _logger = logger;
        _signalsPath = signalsPath ?? "../Intelligence/data/signals/latest.json";
        _jsonOptions = new JsonSerializerOptions
        {
            PropertyNameCaseInsensitive = true,
            ReadCommentHandling = JsonCommentHandling.Skip,
            AllowTrailingCommas = true
        };
    }

    /// <summary>
    /// Gets the latest market intelligence. Returns null if intelligence is unavailable.
    /// The bot should continue normally when this returns null.
    /// </summary>
    /// <returns>Market context if available, null otherwise</returns>
    public async Task<MarketContext?> GetLatestIntelligenceAsync()
    {
        try
        {
            if (!File.Exists(_signalsPath))
            {
                _logger.LogDebug("[INTEL] Signals file not found: {Path}", _signalsPath);
                return null;
            }

            var json = await File.ReadAllTextAsync(_signalsPath);
            if (string.IsNullOrWhiteSpace(json))
            {
                _logger.LogDebug("[INTEL] Signals file is empty");
                return null;
            }

            var marketContext = JsonSerializer.Deserialize<MarketContext>(json, _jsonOptions);
            if (marketContext != null)
            {
                _logger.LogInformation("[INTEL] Successfully loaded intelligence: Regime={Regime}, Confidence={Confidence:F2}, Bias={Bias}",
                    marketContext.Regime, marketContext.ModelConfidence, marketContext.PrimaryBias);
            }

            return marketContext;
        }
        catch (JsonException ex)
        {
            _logger.LogWarning("[INTEL] Failed to parse signals file: {Error}", ex.Message);
            return null;
        }
        catch (Exception ex)
        {
            _logger.LogDebug("[INTEL] Intelligence unavailable: {Error}", ex.Message);
            return null;
        }
    }

    /// <summary>
    /// Checks if intelligence is currently available
    /// </summary>
    public bool IsIntelligenceAvailable()
    {
        return File.Exists(_signalsPath);
    }

    /// <summary>
    /// Gets the age of the latest intelligence data in minutes
    /// </summary>
    public TimeSpan? GetIntelligenceAge()
    {
        try
        {
            if (!File.Exists(_signalsPath))
                return null;

            var fileInfo = new FileInfo(_signalsPath);
            return DateTime.UtcNow - fileInfo.LastWriteTimeUtc;
        }
        catch
        {
            return null;
        }
    }

    /// <summary>
    /// Logs a trade result for the Intelligence feedback loop
    /// </summary>
    public async Task LogTradeResultAsync(string symbol, decimal entryPrice, decimal exitPrice, 
        decimal pnl, MarketContext? intelligenceUsed = null)
    {
        try
        {
            var resultsFolderPath = Path.GetDirectoryName(_signalsPath)?.Replace("signals", "trades") 
                                   ?? "../Intelligence/data/trades/";
            
            Directory.CreateDirectory(resultsFolderPath);
            
            var resultsPath = Path.Combine(resultsFolderPath, "results.jsonl");
            
            var tradeResult = new
            {
                Timestamp = DateTime.UtcNow,
                Symbol = symbol,
                Entry = entryPrice,
                Exit = exitPrice,
                PnL = pnl,
                IntelligenceUsed = intelligenceUsed != null,
                IntelligenceConfidence = intelligenceUsed?.ModelConfidence ?? 0,
                IntelligenceRegime = intelligenceUsed?.Regime ?? "Unknown",
                IntelligenceBias = intelligenceUsed?.PrimaryBias ?? "Unknown"
            };

            var json = JsonSerializer.Serialize(tradeResult, _jsonOptions);
            await File.AppendAllTextAsync(resultsPath, json + Environment.NewLine);
            
            _logger.LogDebug("[INTEL] Logged trade result: {Symbol} PnL={PnL:F2} with intelligence={HasIntel}",
                symbol, pnl, intelligenceUsed != null);
        }
        catch (Exception ex)
        {
            _logger.LogWarning("[INTEL] Failed to log trade result: {Error}", ex.Message);
        }
    }
}