using System;
using System.Collections.Concurrent;
using System.Globalization;

namespace BotCore.Utilities
{
    /// <summary>
    /// Standardized customTag generator for idempotency and single format across all order systems
    /// Replaces multiple generators/variants for unified auditing and idempotency tracking
    /// </summary>
    public static class CustomTagGenerator
    {
        // Constants for tag generation limits and formatting
        private const int MaxSequenceLimit = 999;
        private const int GuidSubstringLength = 20;
        
        // Constants for tag format validation
        private const int DateFormatLength = 8;          // YYYYMMDD
        private const int TimeFormatLength = 6;          // HHMMSS  
        private const int MinimumTagParts = 3;           // Minimum parts for valid tag
        private const int DatePartIndex = 1;             // Index of date part in split tag
        private const int TimePartIndex = 2;             // Index of time part in split tag
        private const int DefaultSymbolAbbreviationLength = 2; // Default length for symbol abbreviations
        
        private static readonly ConcurrentDictionary<string, DateTime> _generatedTags = new();
        private static readonly object _lock = new();
        
        /// <summary>
        /// Generate unique customTag with standardized format: S11L-YYYYMMDD-HHMMSS-XXX
        /// Ensures idempotency by preventing duplicate tags within the same second
        /// Used across TradingSystemConnector, OrderFillConfirmationSystem, and all order placement
        /// </summary>
        /// <param name="strategyId">Optional strategy identifier for lineage tracking</param>
        /// <param name="side">Optional side (BUY/SELL) for duplicate detection</param>
        /// <returns>Unique customTag in format S11L-YYYYMMDD-HHMMSS-XXX</returns>
        public static string Generate(string? strategyId = null, string? side = null)
        {
            lock (_lock)
            {
                var now = DateTime.UtcNow;
                var baseTag = $"S11L-{now:yyyyMMdd-HHmmss}";
                
                // Add sequence number if multiple tags generated in same second
                var sequence = 1;
                var candidateTag = baseTag;
                
                while (_generatedTags.ContainsKey(candidateTag))
                {
                    candidateTag = $"{baseTag}-{sequence:D3}";
                    sequence++;
                    
                    // Safety limit to prevent infinite loop
                    if (sequence > MaxSequenceLimit)
                    {
                        candidateTag = $"{baseTag}-{Guid.NewGuid():N}"[..GuidSubstringLength];
                        break;
                    }
                }
                
                // Track generated tag for idempotency
                _generatedTags[candidateTag] = now;
                
                // Cleanup old tags (older than 1 hour) to prevent memory growth
                var cutoff = now.AddHours(-1);
                var toRemove = new List<string>();
                foreach (var kvp in _generatedTags)
                {
                    if (kvp.Value < cutoff)
                        toRemove.Add(kvp.Key);
                }
                foreach (var key in toRemove)
                {
                    _generatedTags.TryRemove(key, out _);
                }
                
                return candidateTag;
            }
        }
        
        /// <summary>
        /// Generate customTag with strategy context for enhanced lineage tracking
        /// Format: S11L-YYYYMMDD-HHMMSS-{strategyCode}
        /// </summary>
        /// <param name="strategyId">Strategy identifier (e.g., "EMA", "MACD")</param>
        /// <param name="symbol">Trading symbol (e.g., "ES", "NQ")</param>
        /// <param name="side">Order side ("BUY" or "SELL")</param>
        /// <returns>Enhanced customTag with strategy context</returns>
        public static string GenerateWithContext(string strategyId, string symbol, string side)
        {
            var baseTag = Generate(strategyId, side);
            var symbolCode = GetSymbolCode(symbol);
            var sideCode = side?.ToUpperInvariant() switch
            {
                "BUY" => "B",
                "SELL" => "S",
                _ => "X"
            };
            
            // Replace the default suffix with context: S11L-YYYYMMDD-HHMMSS-ESB (ES Buy)
            var parts = baseTag.Split('-');
            if (parts.Length >= MinimumTagParts)
            {
                return $"{parts[0]}-{parts[DatePartIndex]}-{parts[TimePartIndex]}-{symbolCode}{sideCode}";
            }
            
            return baseTag;
        }
        
        /// <summary>
        /// Validate if a customTag was generated by this system
        /// </summary>
        /// <param name="customTag">Tag to validate</param>
        /// <returns>True if tag matches expected format</returns>
        public static bool IsValidFormat(string customTag)
        {
            if (string.IsNullOrEmpty(customTag))
                return false;
                
            // Expected format: S11L-YYYYMMDD-HHMMSS-XXX
            var parts = customTag.Split('-');
            if (parts.Length < MinimumTagParts || parts[0] != "S11L")
                return false;
                
            // Validate date part (YYYYMMDD)
            if (parts[DatePartIndex].Length != DateFormatLength || !DateTime.TryParseExact(parts[DatePartIndex], "yyyyMMdd", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out _))
                return false;
                
            // Validate time part (HHMMSS)  
            if (parts[TimePartIndex].Length != TimeFormatLength || !DateTime.TryParseExact(parts[TimePartIndex], "HHmmss", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out _))
                return false;
                
            return true;
        }
        
        /// <summary>
        /// Extract timestamp from customTag for auditing purposes
        /// </summary>
        /// <param name="customTag">Tag to parse</param>
        /// <returns>DateTime if parseable, null otherwise</returns>
        public static DateTime? ExtractTimestamp(string customTag)
        {
            if (!IsValidFormat(customTag))
                return null;
                
            var parts = customTag.Split('-');
            var dateStr = parts[1];
            var timeStr = parts[2];
            
            if (DateTime.TryParseExact($"{dateStr} {timeStr}", "yyyyMMdd HHmmss", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out var timestamp))
            {
                return timestamp;
            }
            
            return null;
        }
        
        private static string GetSymbolCode(string symbol)
        {
            return symbol?.ToUpperInvariant() switch
            {
                "ES" => "ES",
                "NQ" => "NQ", 
                "YM" => "YM",
                "RTY" => "RT",
                _ => symbol?.ToUpperInvariant()[..Math.Min(DefaultSymbolAbbreviationLength, symbol.Length)] ?? "XX"
            };
        }
    }
}