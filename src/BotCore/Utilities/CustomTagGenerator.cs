using System;
using System.Collections.Concurrent;
using System.Globalization;

namespace BotCore.Utilities
{
    /// <summary>
    /// Standardized customTag generator for idempotency and single format across all order systems
    /// Replaces multiple generators/variants for unified auditing and idempotency tracking
    /// </summary>
    public static class CustomTagGenerator
    {
        private static readonly ConcurrentDictionary<string, DateTime> _generatedTags = new();
        private static readonly object _lock = new();
        
        /// <summary>
        /// Generate unique customTag with standardized format: S11L-YYYYMMDD-HHMMSS-XXX
        /// Ensures idempotency by preventing duplicate tags within the same second
        /// Used across TradingSystemConnector, OrderFillConfirmationSystem, and all order placement
        /// </summary>
        /// <param name="strategyId">Optional strategy identifier for lineage tracking</param>
        /// <param name="side">Optional side (BUY/SELL) for duplicate detection</param>
        /// <returns>Unique customTag in format S11L-YYYYMMDD-HHMMSS-XXX</returns>
        public static string Generate(string? strategyId = null, string? side = null)
        {
            lock (_lock)
            {
                var now = DateTime.UtcNow;
                var baseTag = $"S11L-{now:yyyyMMdd-HHmmss}";
                
                // Add sequence number if multiple tags generated in same second
                var sequence = 1;
                var candidateTag = baseTag;
                
                while (_generatedTags.ContainsKey(candidateTag))
                {
                    candidateTag = $"{baseTag}-{sequence:D3}";
                    sequence++;
                    
                    // Safety limit to prevent infinite loop
                    if (sequence > 999)
                    {
                        candidateTag = $"{baseTag}-{Guid.NewGuid():N}"[..20];
                        break;
                    }
                }
                
                // Track generated tag for idempotency
                _generatedTags[candidateTag] = now;
                
                // Cleanup old tags (older than 1 hour) to prevent memory growth
                var cutoff = now.AddHours(-1);
                var toRemove = new List<string>();
                foreach (var kvp in _generatedTags)
                {
                    if (kvp.Value < cutoff)
                        toRemove.Add(kvp.Key);
                }
                foreach (var key in toRemove)
                {
                    _generatedTags.TryRemove(key, out _);
                }
                
                return candidateTag;
            }
        }
        
        /// <summary>
        /// Generate customTag with strategy context for enhanced lineage tracking
        /// Format: S11L-YYYYMMDD-HHMMSS-{strategyCode}
        /// </summary>
        /// <param name="strategyId">Strategy identifier (e.g., "EMA", "MACD")</param>
        /// <param name="symbol">Trading symbol (e.g., "ES", "NQ")</param>
        /// <param name="side">Order side ("BUY" or "SELL")</param>
        /// <returns>Enhanced customTag with strategy context</returns>
        public static string GenerateWithContext(string strategyId, string symbol, string side)
        {
            var baseTag = Generate(strategyId, side);
            var strategyCode = GetStrategyCode(strategyId);
            var symbolCode = GetSymbolCode(symbol);
            var sideCode = side?.ToUpperInvariant() switch
            {
                "BUY" => "B",
                "SELL" => "S",
                _ => "X"
            };
            
            // Replace the default suffix with context: S11L-YYYYMMDD-HHMMSS-ESB (ES Buy)
            var parts = baseTag.Split('-');
            if (parts.Length >= 3)
            {
                return $"{parts[0]}-{parts[1]}-{parts[2]}-{symbolCode}{sideCode}";
            }
            
            return baseTag;
        }
        
        /// <summary>
        /// Validate if a customTag was generated by this system
        /// </summary>
        /// <param name="customTag">Tag to validate</param>
        /// <returns>True if tag matches expected format</returns>
        public static bool IsValidFormat(string customTag)
        {
            if (string.IsNullOrEmpty(customTag))
                return false;
                
            // Expected format: S11L-YYYYMMDD-HHMMSS-XXX
            var parts = customTag.Split('-');
            if (parts.Length < 3 || parts[0] != "S11L")
                return false;
                
            // Validate date part (YYYYMMDD)
            if (parts[1].Length != 8 || !DateTime.TryParseExact(parts[1], "yyyyMMdd", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out _))
                return false;
                
            // Validate time part (HHMMSS)  
            if (parts[2].Length != 6 || !DateTime.TryParseExact(parts[2], "HHmmss", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out _))
                return false;
                
            return true;
        }
        
        /// <summary>
        /// Extract timestamp from customTag for auditing purposes
        /// </summary>
        /// <param name="customTag">Tag to parse</param>
        /// <returns>DateTime if parseable, null otherwise</returns>
        public static DateTime? ExtractTimestamp(string customTag)
        {
            if (!IsValidFormat(customTag))
                return null;
                
            var parts = customTag.Split('-');
            var dateStr = parts[1];
            var timeStr = parts[2];
            
            if (DateTime.TryParseExact($"{dateStr} {timeStr}", "yyyyMMdd HHmmss", 
                CultureInfo.InvariantCulture, DateTimeStyles.None, out var timestamp))
            {
                return timestamp;
            }
            
            return null;
        }
        
        private static string GetStrategyCode(string strategyId)
        {
            return strategyId?.ToUpperInvariant() switch
            {
                "EMA" or "EMACROSS" => "EM",
                "MACD" => "MA", 
                "RSI" => "RS",
                "BOLLINGER" => "BB",
                "MEAN_REVERSION" => "MR",
                _ => "GN" // Generic
            };
        }
        
        private static string GetSymbolCode(string symbol)
        {
            return symbol?.ToUpperInvariant() switch
            {
                "ES" or "MES" => "ES",
                "NQ" or "MNQ" => "NQ", 
                "YM" or "MYM" => "YM",
                "RTY" or "M2K" => "RT",
                _ => symbol?.ToUpperInvariant()[..Math.Min(2, symbol.Length)] ?? "XX"
            };
        }
    }
}