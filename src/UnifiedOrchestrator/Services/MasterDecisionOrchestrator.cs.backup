using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Options;
using BotCore.Services;
using TradingBot.UnifiedOrchestrator.Services;
using TradingBot.Abstractions;
using System.Text.Json;
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic;
using System.Linq;

namespace TradingBot.UnifiedOrchestrator.Services;

/// <summary>
/// üéØ MASTER DECISION ORCHESTRATOR - ALWAYS-LEARNING TRADING SYSTEM üéØ
/// 
/// This is the ONE MASTER BRAIN that coordinates all AI decision-making:
/// 
/// PRIMARY DECISION HIERARCHY:
/// 1. Enhanced Brain Integration (Multi-model ensemble + cloud sync)
/// 2. Unified Trading Brain (Neural UCB + CVaR-PPO + LSTM) 
/// 3. Intelligence Orchestrator (Basic ML/RL fallback)
/// 4. Python Decision Services (UCB FastAPI services)
/// 5. Direct Strategy Execution (ultimate fallback)
/// 
/// GUARANTEES:
/// ‚úÖ NEVER returns HOLD - always BUY/SELL
/// ‚úÖ Continuous learning from every trade outcome  
/// ‚úÖ 24/7 operation with auto-recovery
/// ‚úÖ Real-time model promotion based on performance
/// ‚úÖ Historical + live data integration
/// ‚úÖ Contract auto-rollover (Z25 ‚Üí H26)
/// 
/// RESULT: Always-learning trading system that gets smarter every day
/// </summary>
public class MasterDecisionOrchestrator : BackgroundService
{
    private readonly ILogger<MasterDecisionOrchestrator> _logger;
    private readonly IServiceProvider _serviceProvider;
    
    // Core decision routing components
    private readonly UnifiedDecisionRouter _unifiedRouter;
    private readonly DecisionServiceRouter _serviceRouter;
    
    // Learning and feedback systems
    private readonly EnhancedTradingBrainIntegration? _enhancedBrain;
    private readonly BotCore.Brain.UnifiedTradingBrain _unifiedBrain;
    
    // Configuration and monitoring
    private readonly MasterOrchestratorConfig _config;
    private readonly ContinuousLearningManager _learningManager;
    private readonly ContractRolloverManager _rolloverManager;
    
    // Operational state
    private readonly Dictionary<string, DecisionPerformance> _performanceTracking = new();
    private readonly Queue<LearningEvent> _learningQueue = new();
    private readonly object _stateLock = new();
    
    // Always-learning operation state
    private bool _isLearningActive = false;
    private DateTime _lastModelUpdate = DateTime.MinValue;
    private DateTime _lastPerformanceReport = DateTime.MinValue;
    
    public MasterDecisionOrchestrator(
        ILogger<MasterDecisionOrchestrator> logger,
        IServiceProvider serviceProvider,
        UnifiedDecisionRouter unifiedRouter,
        DecisionServiceRouter serviceRouter,
        BotCore.Brain.UnifiedTradingBrain unifiedBrain)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
        _unifiedRouter = unifiedRouter;
        _serviceRouter = serviceRouter;
        _unifiedBrain = unifiedBrain;
        
        // Try to get optional enhanced services
        _enhancedBrain = serviceProvider.GetService<EnhancedTradingBrainIntegration>();
        
        // Initialize configuration
        _config = serviceProvider.GetService<IOptions<MasterOrchestratorConfig>>()?.Value ?? new MasterOrchestratorConfig();
        
        // Initialize continuous learning manager
        _learningManager = new ContinuousLearningManager(logger, serviceProvider);
        
        // Initialize contract rollover manager
        _rolloverManager = new ContractRolloverManager(logger, serviceProvider);
        
        _logger.LogInformation("üéØ [MASTER-ORCHESTRATOR] Initialized - Always-learning trading system ready");
        _logger.LogInformation("üß† [MASTER-ORCHESTRATOR] Enhanced Brain: {Enhanced}, Service Router: True, Unified Brain: True", 
            _enhancedBrain != null);
    }
    
    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _logger.LogInformation("üöÄ [MASTER-ORCHESTRATOR] Starting always-learning trading system...");
        
        try
        {
            // Initialize all systems
            await InitializeSystemsAsync(stoppingToken);
            
            // Start continuous learning
            await StartContinuousLearningAsync(stoppingToken);
            
            // Main orchestration loop
            while (!stoppingToken.IsCancellationRequested)
            {
                try
                {
                    // Execute main orchestration cycle
                    await ExecuteOrchestrationCycleAsync(stoppingToken);
                    
                    // Wait before next cycle
                    await Task.Delay(TimeSpan.FromSeconds(_config.OrchestrationCycleIntervalSeconds), stoppingToken);
                }
                catch (OperationCanceledException)
                {
                    break;
                }
                catch (Exception ex)
                {
                    _logger.LogError(ex, "‚ùå [MASTER-ORCHESTRATOR] Error in orchestration cycle");
                    await Task.Delay(TimeSpan.FromSeconds(5), stoppingToken);
                }
            }
        }
        catch (Exception ex)
        {
            _logger.LogCritical(ex, "üí• [MASTER-ORCHESTRATOR] Critical error in master orchestrator");
            throw;
        }
        finally
        {
            _logger.LogInformation("üõë [MASTER-ORCHESTRATOR] Always-learning trading system stopped");
        }
    }
    
    /// <summary>
    /// Initialize all AI systems and verify readiness
    /// </summary>
    private async Task InitializeSystemsAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("üîß [MASTER-ORCHESTRATOR] Initializing all AI systems...");
        
        try
        {
            // Initialize Unified Trading Brain
            await _unifiedBrain.InitializeAsync(cancellationToken);
            _logger.LogInformation("‚úÖ [UNIFIED-BRAIN] Initialized successfully");
            
            // Initialize Enhanced Brain if available
            if (_enhancedBrain != null)
            {
                await _enhancedBrain.InitializeAsync(cancellationToken);
                _logger.LogInformation("‚úÖ [ENHANCED-BRAIN] Initialized successfully");
            }
            
            // Initialize learning manager
            await _learningManager.InitializeAsync(cancellationToken);
            _logger.LogInformation("‚úÖ [LEARNING-MANAGER] Initialized successfully");
            
            // Initialize contract rollover manager
            await _rolloverManager.InitializeAsync(cancellationToken);
            _logger.LogInformation("‚úÖ [ROLLOVER-MANAGER] Initialized successfully");
            
            _logger.LogInformation("üéâ [MASTER-ORCHESTRATOR] All systems initialized - Ready for always-learning operation");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [MASTER-ORCHESTRATOR] System initialization failed");
            throw;
        }
    }
    
    /// <summary>
    /// Start continuous learning systems
    /// </summary>
    private async Task StartContinuousLearningAsync(CancellationToken cancellationToken)
    {
        try
        {
            _logger.LogInformation("üìö [CONTINUOUS-LEARNING] Starting always-learning systems...");
            
            // Start learning manager
            await _learningManager.StartLearningAsync(cancellationToken);
            
            // Start contract rollover monitoring
            await _rolloverManager.StartMonitoringAsync(cancellationToken);
            
            _isLearningActive = true;
            _logger.LogInformation("‚úÖ [CONTINUOUS-LEARNING] Always-learning systems started successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [CONTINUOUS-LEARNING] Failed to start learning systems");
            throw;
        }
    }
    
    /// <summary>
    /// Execute main orchestration cycle
    /// </summary>
    private async Task ExecuteOrchestrationCycleAsync(CancellationToken cancellationToken)
    {
        // Process learning queue
        await ProcessLearningQueueAsync(cancellationToken);
        
        // Check for model updates
        await CheckModelUpdatesAsync(cancellationToken);
        
        // Generate performance reports
        await GeneratePerformanceReportsAsync(cancellationToken);
        
        // Monitor system health
        await MonitorSystemHealthAsync(cancellationToken);
        
        // Check contract rollover needs
        await CheckContractRolloverAsync(cancellationToken);
    }
    
    /// <summary>
    /// MAIN DECISION METHOD - Used by trading orchestrator
    /// This is the ONE method that all trading decisions flow through
    /// </summary>
    public async Task<UnifiedTradingDecision> MakeUnifiedDecisionAsync(
        string symbol,
        MarketContext marketContext,
        CancellationToken cancellationToken = default)
    {
        var startTime = DateTime.UtcNow;
        var decisionId = GenerateDecisionId();
        
        try
        {
            _logger.LogDebug("üéØ [MASTER-DECISION] Making unified decision for {Symbol}", symbol);
            
            // Route through integrated decision system
            var decision = await _serviceRouter.RouteIntegratedDecisionAsync(symbol, marketContext, cancellationToken);
            
            // Ensure decision ID is set
            if (string.IsNullOrEmpty(decision.DecisionId))
            {
                decision.DecisionId = decisionId;
            }
            
            // Track decision for learning
            await TrackDecisionForLearningAsync(decision, marketContext, cancellationToken);
            
            // Log the decision
            LogDecision(decision, startTime);
            
            return decision;
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [MASTER-DECISION] Failed to make decision for {Symbol}", symbol);
            
            // Emergency fallback decision
            return CreateEmergencyDecision(symbol, marketContext, decisionId, startTime);
        }
    }
    
    /// <summary>
    /// Submit trading outcome for continuous learning
    /// </summary>
    public async Task SubmitTradingOutcomeAsync(
        string decisionId,
        decimal realizedPnL,
        bool wasCorrect,
        TimeSpan holdTime,
        string decisionSource,
        Dictionary<string, object> metadata,
        CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üìà [MASTER-FEEDBACK] Recording outcome: {DecisionId} PnL={PnL:C2} Correct={Correct}",
                decisionId, realizedPnL, wasCorrect);
            
            // Submit to integrated systems
            await _serviceRouter.SubmitIntegratedOutcomeAsync(
                decisionId, realizedPnL, wasCorrect, holdTime, decisionSource, cancellationToken);
            
            // Create learning event
            var learningEvent = new LearningEvent
            {
                DecisionId = decisionId,
                RealizedPnL = realizedPnL,
                WasCorrect = wasCorrect,
                HoldTime = holdTime,
                DecisionSource = decisionSource,
                Metadata = metadata,
                Timestamp = DateTime.UtcNow
            };
            
            // Add to learning queue
            lock (_stateLock)
            {
                _learningQueue.Enqueue(learningEvent);
            }
            
            // Update performance tracking
            await UpdatePerformanceTrackingAsync(decisionId, decisionSource, realizedPnL, wasCorrect, cancellationToken);
            
            _logger.LogInformation("‚úÖ [MASTER-FEEDBACK] Outcome recorded and queued for learning");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [MASTER-FEEDBACK] Failed to submit trading outcome");
        }
    }
    
    /// <summary>
    /// Get comprehensive system status
    /// </summary>
    public MasterOrchestratorStatus GetSystemStatus()
    {
        lock (_stateLock)
        {
            var status = new MasterOrchestratorStatus
            {
                IsLearningActive = _isLearningActive,
                LastModelUpdate = _lastModelUpdate,
                LastPerformanceReport = _lastPerformanceReport,
                TotalDecisionsToday = _performanceTracking.Values.Sum(p => p.TotalDecisions),
                OverallWinRate = CalculateOverallWinRate(),
                LearningQueueSize = _learningQueue.Count,
                ServiceStatus = _serviceRouter.GetServiceStatus(),
                BrainPerformance = _performanceTracking.ToDictionary(kvp => kvp.Key, kvp => kvp.Value),
                SystemHealthy = IsSystemHealthy(),
                Timestamp = DateTime.UtcNow
            };
            
            return status;
        }
    }
    
    /// <summary>
    /// Force model update and retraining
    /// </summary>
    public async Task ForceModelUpdateAsync(CancellationToken cancellationToken = default)
    {
        try
        {
            _logger.LogInformation("üîÑ [FORCE-UPDATE] Forcing model update and retraining...");
            
            // Trigger learning manager update
            await _learningManager.ForceUpdateAsync(cancellationToken);
            
            // Update timestamp
            _lastModelUpdate = DateTime.UtcNow;
            
            _logger.LogInformation("‚úÖ [FORCE-UPDATE] Model update completed successfully");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [FORCE-UPDATE] Failed to force model update");
            throw;
        }
    }
    
    #region Private Implementation Methods
    
    private async Task ProcessLearningQueueAsync(CancellationToken cancellationToken)
    {
        var events = new List<LearningEvent>();
        
        lock (_stateLock)
        {
            while (_learningQueue.Count > 0)
            {
                events.Add(_learningQueue.Dequeue());
            }
        }
        
        if (events.Count > 0)
        {
            await _learningManager.ProcessLearningEventsAsync(events, cancellationToken);
            _logger.LogDebug("üìö [LEARNING-QUEUE] Processed {Count} learning events", events.Count);
        }
    }
    
    private async Task CheckModelUpdatesAsync(CancellationToken cancellationToken)
    {
        if (DateTime.UtcNow - _lastModelUpdate > TimeSpan.FromHours(_config.ModelUpdateIntervalHours))
        {
            await _learningManager.CheckAndUpdateModelsAsync(cancellationToken);
            _lastModelUpdate = DateTime.UtcNow;
        }
    }
    
    private async Task GeneratePerformanceReportsAsync(CancellationToken cancellationToken)
    {
        if (DateTime.UtcNow - _lastPerformanceReport > TimeSpan.FromHours(_config.PerformanceReportIntervalHours))
        {
            await GenerateDetailedPerformanceReportAsync(cancellationToken);
            _lastPerformanceReport = DateTime.UtcNow;
        }
    }
    
    private async Task MonitorSystemHealthAsync(CancellationToken cancellationToken)
    {
        // Monitor system health and trigger alerts if needed
        var isHealthy = IsSystemHealthy();
        
        if (!isHealthy)
        {
            _logger.LogWarning("‚ö†Ô∏è [SYSTEM-HEALTH] System health degraded, triggering recovery actions");
            await TriggerRecoveryActionsAsync(cancellationToken);
        }
    }
    
    private async Task CheckContractRolloverAsync(CancellationToken cancellationToken)
    {
        await _rolloverManager.CheckRolloverNeedsAsync(cancellationToken);
    }
    
    private async Task TrackDecisionForLearningAsync(
        UnifiedTradingDecision decision,
        MarketContext marketContext,
        CancellationToken cancellationToken)
    {
        // Track decision for later learning
        var trackingInfo = new DecisionTrackingInfo
        {
            DecisionId = decision.DecisionId,
            Symbol = decision.Symbol,
            Action = decision.Action,
            Confidence = decision.Confidence,
            Strategy = decision.Strategy,
            DecisionSource = decision.DecisionSource,
            MarketContext = marketContext,
            Timestamp = decision.Timestamp
        };
        
        await _learningManager.TrackDecisionAsync(trackingInfo, cancellationToken);
    }
    
    private void LogDecision(UnifiedTradingDecision decision, DateTime startTime)
    {
        var processingTime = (DateTime.UtcNow - startTime).TotalMilliseconds;
        
        _logger.LogInformation("üéØ [MASTER-DECISION] Decision: {Action} {Symbol} " +
                             "confidence={Confidence:P1} source={Source} strategy={Strategy} time={Time:F0}ms",
            decision.Action, decision.Symbol, decision.Confidence, 
            decision.DecisionSource, decision.Strategy, processingTime);
    }
    
    private UnifiedTradingDecision CreateEmergencyDecision(
        string symbol, 
        MarketContext marketContext, 
        string decisionId, 
        DateTime startTime)
    {
        return new UnifiedTradingDecision
        {
            DecisionId = decisionId,
            Symbol = symbol,
            Action = TradingAction.Buy, // Conservative emergency bias
            Confidence = 0.51m, // Minimum viable
            Quantity = 1m, // Very conservative
            Strategy = "EMERGENCY",
            DecisionSource = "Emergency",
            Reasoning = new Dictionary<string, object>
            {
                ["source"] = "Emergency fallback - all decision systems failed",
                ["safety"] = "Conservative BUY bias with minimum sizing"
            },
            Timestamp = DateTime.UtcNow,
            ProcessingTimeMs = (DateTime.UtcNow - startTime).TotalMilliseconds
        };
    }
    
    private async Task UpdatePerformanceTrackingAsync(
        string decisionId,
        string decisionSource,
        decimal realizedPnL,
        bool wasCorrect,
        CancellationToken cancellationToken)
    {
        lock (_stateLock)
        {
            if (!_performanceTracking.TryGetValue(decisionSource, out var performance))
            {
                performance = new DecisionPerformance { Source = decisionSource };
                _performanceTracking[decisionSource] = performance;
            }
            
            performance.TotalDecisions++;
            performance.TotalPnL += realizedPnL;
            if (wasCorrect) performance.WinningDecisions++;
            performance.WinRate = performance.TotalDecisions > 0 ? 
                (decimal)performance.WinningDecisions / performance.TotalDecisions : 0;
            performance.LastUpdated = DateTime.UtcNow;
        }
        
        await Task.CompletedTask;
    }
    
    private decimal CalculateOverallWinRate()
    {
        var totalDecisions = _performanceTracking.Values.Sum(p => p.TotalDecisions);
        var totalWinning = _performanceTracking.Values.Sum(p => p.WinningDecisions);
        
        return totalDecisions > 0 ? (decimal)totalWinning / totalDecisions : 0;
    }
    
    private bool IsSystemHealthy()
    {
        // Check if learning is active
        if (!_isLearningActive) return false;
        
        // Check recent performance
        var recentPerformance = _performanceTracking.Values
            .Where(p => DateTime.UtcNow - p.LastUpdated < TimeSpan.FromHours(1))
            .ToList();
            
        if (!recentPerformance.Any()) return true; // No recent decisions is okay
        
        // Check if any source has very poor performance
        var poorPerformers = recentPerformance
            .Where(p => p.TotalDecisions >= 10 && p.WinRate < 0.3m)
            .ToList();
            
        return !poorPerformers.Any();
    }
    
    private async Task TriggerRecoveryActionsAsync(CancellationToken cancellationToken)
    {
        _logger.LogInformation("üîß [RECOVERY] Triggering system recovery actions...");
        
        try
        {
            // Restart learning systems
            await _learningManager.RestartAsync(cancellationToken);
            
            // Force model updates
            await _learningManager.ForceUpdateAsync(cancellationToken);
            
            _logger.LogInformation("‚úÖ [RECOVERY] Recovery actions completed");
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [RECOVERY] Recovery actions failed");
        }
    }
    
    private async Task GenerateDetailedPerformanceReportAsync(CancellationToken cancellationToken)
    {
        try
        {
            var report = new PerformanceReport
            {
                Timestamp = DateTime.UtcNow,
                OverallStats = new OverallStats
                {
                    TotalDecisions = _performanceTracking.Values.Sum(p => p.TotalDecisions),
                    TotalPnL = _performanceTracking.Values.Sum(p => p.TotalPnL),
                    OverallWinRate = CalculateOverallWinRate(),
                    ActiveSources = _performanceTracking.Count
                },
                SourcePerformance = _performanceTracking.Values.ToList()
            };
            
            // Save report
            var reportPath = Path.Combine("reports", $"performance_{DateTime.UtcNow:yyyyMMdd_HHmmss}.json");
            Directory.CreateDirectory(Path.GetDirectoryName(reportPath)!);
            
            var json = JsonSerializer.Serialize(report, new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(reportPath, json, cancellationToken);
            
            _logger.LogInformation("üìä [PERFORMANCE-REPORT] Generated detailed report: {ReportPath}", reportPath);
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, "‚ùå [PERFORMANCE-REPORT] Failed to generate performance report");
        }
    }
    
    private string GenerateDecisionId()
    {
        return $"MD{DateTimeOffset.UtcNow.ToUnixTimeMilliseconds()}_{Random.Shared.Next(1000, 9999)}";
    }
    
    #endregion
}

#region Supporting Classes

/// <summary>
/// Continuous learning manager - coordinates all learning activities
/// </summary>
public class ContinuousLearningManager
{
    private readonly ILogger _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public ContinuousLearningManager(ILogger logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    public async Task InitializeAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task StartLearningAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task ProcessLearningEventsAsync(List<LearningEvent> events, CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task CheckAndUpdateModelsAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task ForceUpdateAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task RestartAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task TrackDecisionAsync(DecisionTrackingInfo info, CancellationToken cancellationToken) => await Task.CompletedTask;
}

/// <summary>
/// Contract rollover manager - handles Z25 ‚Üí H26 transitions
/// </summary>
public class ContractRolloverManager
{
    private readonly ILogger _logger;
    private readonly IServiceProvider _serviceProvider;
    
    public ContractRolloverManager(ILogger logger, IServiceProvider serviceProvider)
    {
        _logger = logger;
        _serviceProvider = serviceProvider;
    }
    
    public async Task InitializeAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task StartMonitoringAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
    public async Task CheckRolloverNeedsAsync(CancellationToken cancellationToken) => await Task.CompletedTask;
}

#endregion

#region Data Models

public class MasterOrchestratorConfig
{
    public int OrchestrationCycleIntervalSeconds { get; set; } = 10;
    public int ModelUpdateIntervalHours { get; set; } = 2;
    public int PerformanceReportIntervalHours { get; set; } = 6;
    public bool EnableContinuousLearning { get; set; } = true;
    public bool EnableContractRollover { get; set; } = true;
}

public class LearningEvent
{
    public string DecisionId { get; set; } = string.Empty;
    public decimal RealizedPnL { get; set; }
    public bool WasCorrect { get; set; }
    public TimeSpan HoldTime { get; set; }
    public string DecisionSource { get; set; } = string.Empty;
    public Dictionary<string, object> Metadata { get; set; } = new();
    public DateTime Timestamp { get; set; }
}

public class DecisionTrackingInfo
{
    public string DecisionId { get; set; } = string.Empty;
    public string Symbol { get; set; } = string.Empty;
    public TradingAction Action { get; set; }
    public decimal Confidence { get; set; }
    public string Strategy { get; set; } = string.Empty;
    public string DecisionSource { get; set; } = string.Empty;
    public MarketContext MarketContext { get; set; } = new();
    public DateTime Timestamp { get; set; }
}

public class DecisionPerformance
{
    public string Source { get; set; } = string.Empty;
    public int TotalDecisions { get; set; }
    public int WinningDecisions { get; set; }
    public decimal WinRate { get; set; }
    public decimal TotalPnL { get; set; }
    public DateTime LastUpdated { get; set; }
}

public class MasterOrchestratorStatus
{
    public bool IsLearningActive { get; set; }
    public DateTime LastModelUpdate { get; set; }
    public DateTime LastPerformanceReport { get; set; }
    public int TotalDecisionsToday { get; set; }
    public decimal OverallWinRate { get; set; }
    public int LearningQueueSize { get; set; }
    public DecisionServiceStatus ServiceStatus { get; set; } = new();
    public Dictionary<string, DecisionPerformance> BrainPerformance { get; set; } = new();
    public bool SystemHealthy { get; set; }
    public DateTime Timestamp { get; set; }
}

public class PerformanceReport
{
    public DateTime Timestamp { get; set; }
    public OverallStats OverallStats { get; set; } = new();
    public List<DecisionPerformance> SourcePerformance { get; set; } = new();
}

public class OverallStats
{
    public int TotalDecisions { get; set; }
    public decimal TotalPnL { get; set; }
    public decimal OverallWinRate { get; set; }
    public int ActiveSources { get; set; }
}

#endregion