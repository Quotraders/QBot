#!/bin/bash

# Production Enforcement Pre-Commit Hook - Zero Tolerance for Non-Production Patterns
# This hook scans for ANY hardcoded values, mock/fake/stub patterns, and development-only code
# Based on requirements from the problem statement

set -e

echo "üîç Running Production Enforcement Checks..."

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Error counter
VIOLATIONS=0

# Function to report violations
report_violation() {
    echo -e "${RED}‚ùå PRODUCTION VIOLATION:${NC} $1"
    VIOLATIONS=$((VIOLATIONS + 1))
}

# Function to report pattern matches (staged files only)
check_pattern() {
    local pattern="$1"
    local description="$2"
    local directories="${3:-src tests scripts}"
    
    # Get staged files that match our target directories and file types
    local staged_files
    staged_files=$(git diff --cached --name-only --diff-filter=ACMR | grep -E "\.(cs|sh|py|json|yml|yaml)$" | grep -E "^(${directories// /|})/" || true)
    
    if [ -z "$staged_files" ]; then
        return 0
    fi
    
    local matches=""
    local file
    for file in $staged_files; do
        # Skip if file was deleted
        if [ ! -f "$file" ]; then
            continue
        fi
        
        # Use Perl regex for consistent whitespace matching
        if grep -P "$pattern" "$file" > /dev/null 2>&1; then
            matches="$matches$file\n"
        fi
    done
    
    if [ -n "$matches" ]; then
        report_violation "$description"
        echo "Staged files containing violations:"
        echo -e "$matches" | sed 's/^/  /'
        echo
    fi
}

echo "Checking for hardcoded numeric literals in business logic..."
check_pattern "return\\s+[0-9]+(\\.[0-9]+)?[^0-9f]|=\\s*[0-9]+(\\.[0-9]+)?[^0-9f]" "Hardcoded numeric literals detected in business logic"

echo "Checking for placeholder/mock/stub patterns..."
check_pattern "\\b(PLACEHOLDER|TEMP|DUMMY|MOCK|FAKE|STUB|HARDCODED|SAMPLE)\\b" "Placeholder/Mock/Stub patterns detected"

echo "Checking for fixed-size arrays..."
check_pattern "new\\s+(byte|int|double|float|decimal)\\[\\s*[0-9]+\\s*\\]" "Fixed-size data arrays detected"

echo "Checking for empty async placeholders..."
check_pattern "Task\\.Yield\\(\\)|Task\\.Delay\\([0-9]+\\)|throw\\s+new\\s+NotImplementedException|return\\s+Task\\.CompletedTask\\s*;" "Empty/placeholder async implementations detected"

echo "Checking for development-only comments..."
check_pattern "//\\s*(for\\s+testing|debug\\s+only|temporary|remove\\s+this|TODO|FIXME|HACK|XXX|STUB|PLACEHOLDER|BUG|NOTE|REVIEW|REFACTOR|OPTIMIZE)" "Development/testing-only code comments detected"

echo "Checking for weak random generation..."
check_pattern "new\\s+Random\\s*\\(|Random\\.Shared" "Weak random number generation detected"

echo "Checking for specific problematic business values..."
check_pattern "\\b(0\\.7|0\\.8|0\\.5|0\\.3|0\\.4|0\\.25|2\\.5|1\\.25|4125\\.25|4125\\.00|4125\\.50)\\b" "Known problematic hardcoded business values detected"

echo "Checking for class/method names with non-production patterns..."
check_pattern "(class|interface|struct|method)\\s+\\w*(Mock|Fake|Stub|Test|Demo|Sample|Placeholder|Temp|Dummy)\\w*" "Non-production patterns in class/method names"

echo "Checking for commented-out code..."
check_pattern "^\\s*//.*[{};]|^\\s*/\\*.*[{};].*\\*/" "Commented-out code blocks detected"

echo "Checking for literal decimals in trading calculations..."
check_pattern "decimal\\s+\\w+\\s*=\\s*[0-9]+\\.[0-9]+[^f]|price\\s*=\\s*[0-9]+\\.[0-9]+|quantity\\s*=\\s*[0-9]+\\.[0-9]+" "Literal decimals in trading calculations"

echo "Checking for magic numbers in business logic contexts..."
check_pattern "(position|confidence|regime|size|threshold|ratio|factor|weight|probability|risk|reward|volatility|correlation|alpha|beta|sharpe|drawdown|var|cvar)\\s*[=:]\\s*[0-9]+(\\.[0-9]+)?" "Magic numbers in business logic contexts"

echo "Checking for hardcoded timeouts and delays..."
check_pattern "Thread\\.Sleep\\([0-9]+\\)|Task\\.Delay\\([0-9]+\\)|TimeSpan\\.FromMilliseconds\\([0-9]+\\)" "Hardcoded timeouts and delays"

echo "Checking for hardcoded connection strings and URLs..."
check_pattern "(connectionString|baseUrl|endpoint)\\s*[=:]\\s*[\"'][^\"']+[\"']" "Hardcoded connection strings or URLs"

echo "Checking for hardcoded array sizes and collection capacities..."
check_pattern "new\\s+\\w+\\[[0-9]+\\]|Capacity\\s*=\\s*[0-9]+|new\\s+List<\\w+>\\([0-9]+\\)" "Hardcoded array sizes or collection capacities"

echo "Checking for ML/RL specific hardcoded values..."
check_pattern "(learningRate|batchSize|epochs|hiddenSize|dropout|momentum|decay|temperature|epsilon|tau|gamma)\\s*[=:]\\s*[0-9]+(\\.[0-9]+)?" "ML/RL hardcoded hyperparameters"

echo "Checking for performance and optimization hardcoded values..."
check_pattern "(bufferSize|cacheSize|poolSize|maxRetries|timeoutMs|intervalMs|windowSize|chunkSize)\\s*[=:]\\s*[0-9]+" "Hardcoded performance optimization values"
# Check for kill.txt existence or DRY_RUN disabled
echo "Checking for production safety guardrails..."
if [ -f "kill.txt" ]; then
    report_violation "kill.txt file exists - this forces DRY_RUN mode and indicates an emergency stop"
fi

# Check .env for DRY_RUN disabled
if [ -f ".env" ] && grep -q "^DRY_RUN=false" .env; then
    report_violation "DRY_RUN is disabled in .env - this enables live trading and should be carefully reviewed"
fi

# Check for reintroduction of legacy projects
echo "Checking for prohibited legacy project reintroduction..."
if find . -name "TradingBot" -type d -o -name "TradingBot.Orchestrators" -type d | grep -q .; then
    report_violation "Legacy TradingBot projects detected - these were removed per audit requirements"
fi

# Check for legacy project references in solution files
if grep -r "TradingBot\|TradingBot\.Orchestrators" *.sln *.props 2>/dev/null | grep -v "TradingBotBusinessLogicValidation"; then
    report_violation "Legacy TradingBot project references found in solution files"
fi

# Mandatory analyzer check - this is the key improvement
echo "Running mandatory analyzer check..."
if command -v ./dev-helper.sh > /dev/null 2>&1; then
    if ! ./dev-helper.sh analyzer-check; then
        report_violation "Analyzer check failed - new warnings detected (existing ~1500 warnings are expected)"
    fi
else
    # Fallback to direct analyzer check if dev-helper.sh not available
    echo "dev-helper.sh not found, running direct analyzer check..."
    if ! dotnet build --no-restore -warnaserror --verbosity quiet 2>/dev/null; then
        report_violation "Analyzer check failed - new warnings detected"
    fi
fi

# Final result
if [ $VIOLATIONS -eq 0 ]; then
    echo -e "${GREEN}‚úÖ All production enforcement checks passed!${NC}"
    exit 0
else
    echo -e "${RED}‚ùå Found $VIOLATIONS production violations. Commit blocked.${NC}"
    echo -e "${YELLOW}All violations must be fixed before committing. Use configuration-driven values instead of hardcoded literals.${NC}"
    exit 1
fi